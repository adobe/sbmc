diff -uarN pbrt/Makefile rendernet_pbrt/Makefile
--- pbrt/Makefile	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/Makefile	2019-09-07 01:14:54.000000000 +0000
@@ -5,12 +5,12 @@
 # common locations for the OpenEXR libraries; may need to be updated
 # for unusual installation locations
 HAVE_EXR=1
-EXR_INCLUDES=-I/usr/local/include/OpenEXR -I/usr/include/OpenEXR -I/opt/local/include/OpenEXR 
-EXR_LIBDIR=-L/usr/local/lib -L/opt/local/lib
+EXR_INCLUDES=-I/usr/local/include/OpenEXR -I/usr/include/OpenEXR #-I/opt/local/include/OpenEXR 
+EXR_LIBDIR=-L/usr/local/lib #-L/opt/local/lib
 
 HAVE_LIBTIFF=0
-TIFF_INCLUDES=-I/usr/local/include -I/opt/local/include
-TIFF_LIBDIR=-L/usr/local/lib -L/opt/local/lib
+TIFF_INCLUDES=-I/usr/local/include #-I/opt/local/include
+TIFF_LIBDIR=-L/usr/local/lib #-L/opt/local/lib
 
 HAVE_DTRACE=0
 
@@ -24,6 +24,7 @@
 MARCH=-m64
 
 # change this to -g3 for debug builds
+# OPT=-g3
 OPT=-O2
 # comment out this line to enable assertions at runtime
 DEFS += -DNDEBUG
@@ -62,12 +63,13 @@
 CC=gcc
 CXX=g++
 LD=$(CXX) $(OPT) $(MARCH)
-INCLUDE=-I. -Icore $(EXR_INCLUDES) $(TIFF_INCLUDES)
+INCLUDE=-I. -Icore $(EXR_INCLUDES) $(TIFF_INCLUDES) -I/usr/include
 WARN=-Wall
 CWD=$(shell pwd)
 CXXFLAGS=$(OPT) $(MARCH) $(INCLUDE) $(WARN) $(DEFS)
 CCFLAGS=$(CXXFLAGS)
-LIBS=$(LEXLIB) $(EXR_LIBDIR) $(EXRLIBS) -lm 
+CXXFLAGS+= -std=gnu++11
+LIBS=$(LEXLIB) $(EXR_LIBDIR) $(EXRLIBS) -lm -llz4
 
 LIB_CSRCS=core/targa.c
 LIB_CXXSRCS  = $(wildcard core/*.cpp) core/pbrtlex.cpp core/pbrtparse.cpp
@@ -170,6 +172,7 @@
 objs/tools_%.o: tools/%.cpp
 	@echo "Building object $@"
 	@$(CXX) $(CXXFLAGS) -o $@ -c $<
+	# @$(CXX) $(CXXFLAGS)  -std=gnu++11 -o $@ -c $<
 
 bin/pbrt: objs/main_pbrt.o objs/libpbrt.a
 	@echo "Linking $@"
diff -uarN pbrt/accelerators/grid.cpp rendernet_pbrt/accelerators/grid.cpp
--- pbrt/accelerators/grid.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/accelerators/grid.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -120,11 +120,10 @@
 }
 
 
-bool GridAccel::Intersect(const Ray &rorig, Intersection *isect) const {
-    PBRT_GRID_INTERSECTION_TEST(const_cast<GridAccel *>(this), const_cast<Ray *>(&rorig));
+bool GridAccel::Intersect(const Ray &ray, Intersection *isect) const {
+    PBRT_GRID_INTERSECTION_TEST(const_cast<GridAccel *>(this), const_cast<Ray *>(&ray));
     // Check ray against overall grid bounds
     float rayT;
-    Ray ray = rorig;
     if (bounds.Inside(ray(ray.mint)))
         rayT = ray.mint;
     else if (!bounds.IntersectP(ray, &rayT))
@@ -138,7 +137,6 @@
     float NextCrossingT[3], DeltaT[3];
     int Step[3], Out[3], Pos[3];
     for (int axis = 0; axis < 3; ++axis) {
-        if (ray.d[axis] == -0.f) ray.d[axis] = 0.f;
         // Compute current voxel for axis
         Pos[axis] = posToVoxel(gridIntersect, axis);
         if (ray.d[axis] >= 0) {
@@ -225,12 +223,11 @@
 }
 
 
-bool GridAccel::IntersectP(const Ray &rorig) const {
-    PBRT_GRID_INTERSECTIONP_TEST(const_cast<GridAccel *>(this), const_cast<Ray *>(&rorig));
+bool GridAccel::IntersectP(const Ray &ray) const {
+    PBRT_GRID_INTERSECTIONP_TEST(const_cast<GridAccel *>(this), const_cast<Ray *>(&ray));
     RWMutexLock lock(*rwMutex, READ);
     // Check ray against overall grid bounds
     float rayT;
-    Ray ray = rorig;
     if (bounds.Inside(ray(ray.mint)))
         rayT = ray.mint;
     else if (!bounds.IntersectP(ray, &rayT))
@@ -244,7 +241,6 @@
     float NextCrossingT[3], DeltaT[3];
     int Step[3], Out[3], Pos[3];
     for (int axis = 0; axis < 3; ++axis) {
-        if (ray.d[axis] == -0.f) ray.d[axis] = 0.f;
         // Compute current voxel for axis
         Pos[axis] = posToVoxel(gridIntersect, axis);
         if (ray.d[axis] >= 0) {
diff -uarN pbrt/cameras/perspective.cpp rendernet_pbrt/cameras/perspective.cpp
--- pbrt/cameras/perspective.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/cameras/perspective.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -42,7 +42,7 @@
         const float screenWindow[4], float sopen, float sclose,
         float lensr, float focald, float fov, Film *f)
     : ProjectiveCamera(cam2world, Perspective(fov, 1e-2f, 1000.f),
-                       screenWindow, sopen, sclose, lensr, focald, f) {
+                       screenWindow, sopen, sclose, lensr, focald, f), fov(fov) {
     // Compute differential changes in origin for perspective camera rays
     dxCamera = RasterToCamera(Point(1,0,0)) - RasterToCamera(Point(0,0,0));
     dyCamera = RasterToCamera(Point(0,1,0)) - RasterToCamera(Point(0,0,0));
diff -uarN pbrt/cameras/perspective.h rendernet_pbrt/cameras/perspective.h
--- pbrt/cameras/perspective.h	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/cameras/perspective.h	2019-09-07 01:14:54.000000000 +0000
@@ -51,6 +51,7 @@
     float GenerateRay(const CameraSample &sample, Ray *) const;
     float GenerateRayDifferential(const CameraSample &sample,
                                   RayDifferential *ray) const;
+    float fov;
 private:
     // PerspectiveCamera Private Data
     Vector dxCamera, dyCamera;
diff -uarN pbrt/core/api.cpp rendernet_pbrt/core/api.cpp
--- pbrt/core/api.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/api.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -64,6 +64,8 @@
 #include "integrators/igi.h"
 #include "integrators/irradiancecache.h"
 #include "integrators/path.h"
+#include "integrators/pathkpcn.h"
+#include "integrators/pathrendernet.h"
 #include "integrators/photonmap.h"
 #include "integrators/single.h"
 #include "integrators/useprobes.h"
@@ -91,6 +93,7 @@
 #include "renderers/aggregatetest.h"
 #include "renderers/createprobes.h"
 #include "renderers/metropolis.h"
+#include "renderers/rendernetrenderer.h"
 #include "renderers/samplerrenderer.h"
 #include "renderers/surfacepoints.h"
 #include "samplers/adaptive.h"
@@ -539,6 +542,10 @@
         si = CreateDirectLightingIntegrator(paramSet);
     else if (name == "path")
         si = CreatePathSurfaceIntegrator(paramSet);
+    else if (name == "pathkpcn")
+        si = CreatePathKPCNSurfaceIntegrator(paramSet);
+    else if (name == "pathrendernet")
+        si = CreatePathRendernetSurfaceIntegrator(paramSet);
     else if (name == "photonmap" || name == "exphotonmap")
         si = CreatePhotonMapSurfaceIntegrator(paramSet);
     else if (name == "irradiancecache")
@@ -1243,6 +1250,38 @@
         renderer = CreateSurfacePointsRenderer(RendererParams, pCamera, camera->shutterOpen);
         RendererParams.ReportUnused();
     }
+    else if (RendererName == "rendernet") {
+        int tileSize = RendererParams.FindOneInt("tilesize", 64);
+
+        int useCameraSpaceNormals = RendererParams.FindOneBool("useCameraSpaceNormals", true);
+        int recordedSamples = RendererParams.FindOneInt("recordedsamples", 1);
+        RendererParams.ReportUnused();
+        Sampler *sampler = MakeSampler(SamplerName, SamplerParams, camera->film, camera);
+        Sampler *sampler2 = MakeSampler(SamplerName, SamplerParams, camera->film, camera);
+
+        ParamSet RecordedSamplerParams = SamplerParams;
+        RecordedSamplerParams.AddInt("pixelsamples", &recordedSamples, 1);
+        Sampler *sampler_recorded = MakeSampler(SamplerName, RecordedSamplerParams, camera->film, camera);
+
+        if (!sampler) Severe("Unable to create sampler.");
+        if (!sampler2) Severe("Unable to create sampler.");
+        if (!sampler_recorded) Severe("Unable to create sampler.");
+
+        // Create surface and volume integrators
+        SurfaceIntegrator *surfaceIntegrator = MakeSurfaceIntegrator(SurfIntegratorName,
+            SurfIntegratorParams);
+        if (!surfaceIntegrator) Severe("Unable to create surface integrator.");
+        VolumeIntegrator *volumeIntegrator = MakeVolumeIntegrator(VolIntegratorName,
+            VolIntegratorParams);
+        if (!volumeIntegrator) Severe("Unable to create volume integrator.");
+        renderer = new RendernetRenderer(sampler, sampler2, sampler_recorded, camera, surfaceIntegrator,
+                                       volumeIntegrator, tileSize, recordedSamples,
+                                       useCameraSpaceNormals);
+        // Warn if no light sources are defined
+        if (lights.size() == 0)
+            Warning("No light sources defined in scene; "
+                "possibly rendering a black image.");
+    }
     else {
         if (RendererName != "sampler")
             Warning("Renderer type \"%s\" unknown.  Using \"sampler\".",
diff -uarN pbrt/core/camera.h rendernet_pbrt/core/camera.h
--- pbrt/core/camera.h	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/camera.h	2019-09-07 01:14:54.000000000 +0000
@@ -65,11 +65,11 @@
     ProjectiveCamera(const AnimatedTransform &cam2world,
         const Transform &proj, const float screenWindow[4],
         float sopen, float sclose, float lensr, float focald, Film *film);
+    float lensRadius, focalDistance;
 protected:
     // ProjectiveCamera Protected Data
     Transform CameraToScreen, RasterToCamera;
     Transform ScreenToRaster, RasterToScreen;
-    float lensRadius, focalDistance;
 };
 
 
diff -uarN pbrt/core/integrator.cpp rendernet_pbrt/core/integrator.cpp
--- pbrt/core/integrator.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/integrator.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -84,7 +84,8 @@
         const Normal &n, const Vector &wo, float rayEpsilon, float time,
         BSDF *bsdf, const Sample *sample, RNG &rng, int lightNumOffset,
         const LightSampleOffsets *lightSampleOffset,
-        const BSDFSampleOffsets *bsdfSampleOffset) {
+        const BSDFSampleOffsets *bsdfSampleOffset, 
+        LightQueryRecord *qr)  {
     // Randomly choose a single light to sample, _light_
     int nLights = int(scene->lights.size());
     if (nLights == 0) return Spectrum(0.);
@@ -110,7 +111,7 @@
     return (float)nLights *
         EstimateDirect(scene, renderer, arena, light, p, n, wo,
                        rayEpsilon, time, bsdf, rng, lightSample,
-                       bsdfSample, BxDFType(BSDF_ALL & ~BSDF_SPECULAR));
+                       bsdfSample, BxDFType(BSDF_ALL & ~BSDF_SPECULAR), qr);
 }
 
 
@@ -118,25 +119,45 @@
         MemoryArena &arena, const Light *light, const Point &p,
         const Normal &n, const Vector &wo, float rayEpsilon, float time,
         const BSDF *bsdf, RNG &rng, const LightSample &lightSample,
-        const BSDFSample &bsdfSample, BxDFType flags) {
+        const BSDFSample &bsdfSample, BxDFType flags, LightQueryRecord *qr) {
     Spectrum Ld(0.);
+    Spectrum Ld_diffuse(0.);
     // Sample light source with multiple importance sampling
     Vector wi;
     float lightPdf, bsdfPdf;
     VisibilityTester visibility;
     Spectrum Li = light->Sample_L(p, rayEpsilon, lightSample, time,
                                   &wi, &lightPdf, &visibility);
+
+    if (qr) {
+      if (visibility.Unoccluded(scene)) {
+        qr->isLightVisible = true;
+      }
+
+      qr->pdfs[0] = lightPdf;
+      qr->set_angles(wi);
+      // TODO: set angles for MIS
+    }
+
     if (lightPdf > 0. && !Li.IsBlack()) {
         Spectrum f = bsdf->f(wo, wi, flags);
+        Spectrum f_diffuse = bsdf->f(wo, wi, BxDFType(BSDF_DIFFUSE|BSDF_REFLECTION));
         if (!f.IsBlack() && visibility.Unoccluded(scene)) {
             // Add light's contribution to reflected radiance
-            Li *= visibility.Transmittance(scene, renderer, NULL, rng, arena);
-            if (light->IsDeltaLight())
+            Spectrum transmittance = visibility.Transmittance(scene, renderer, NULL, rng, arena);
+            Li *= transmittance;
+            if (light->IsDeltaLight()) {
                 Ld += f * Li * (AbsDot(wi, n) / lightPdf);
+                Ld_diffuse += f_diffuse * Li * (AbsDot(wi, n) / lightPdf);
+            }
             else {
                 bsdfPdf = bsdf->Pdf(wo, wi, flags);
+
+                if (qr) qr->pdfs[1] = bsdfPdf;
+
                 float weight = PowerHeuristic(1, lightPdf, 1, bsdfPdf);
                 Ld += f * Li * (AbsDot(wi, n) * weight / lightPdf);
+                Ld_diffuse += f_diffuse * Li * (AbsDot(wi, n) * weight / lightPdf);
             }
         }
     }
@@ -146,12 +167,23 @@
         BxDFType sampledType;
         Spectrum f = bsdf->Sample_f(wo, &wi, bsdfSample, &bsdfPdf, flags,
                                     &sampledType);
+
+        if (qr) qr->pdfs[3] = bsdfPdf;
+
+        Spectrum f_diffuse = bsdf->f(wo, wi, BxDFType(BSDF_DIFFUSE|BSDF_REFLECTION));
         if (!f.IsBlack() && bsdfPdf > 0.) {
             float weight = 1.f;
             if (!(sampledType & BSDF_SPECULAR)) {
                 lightPdf = light->Pdf(p, wi);
-                if (lightPdf == 0.)
-                    return Ld;
+
+                if (qr) qr->pdfs[2] = lightPdf;
+
+                if (lightPdf == 0.) {
+                  if (qr) {
+                    qr->diffuse_lighting = Ld_diffuse;
+                  }
+                  return Ld;
+                }
                 weight = PowerHeuristic(1, bsdfPdf, 1, lightPdf);
             }
             // Add light contribution from BSDF sampling
@@ -159,17 +191,28 @@
             Spectrum Li(0.f);
             RayDifferential ray(p, wi, rayEpsilon, INFINITY, time);
             if (scene->Intersect(ray, &lightIsect)) {
-                if (lightIsect.primitive->GetAreaLight() == light)
+                if (lightIsect.primitive->GetAreaLight() == light) {
                     Li = lightIsect.Le(-wi);
+                }
+            } else {
+              Li = light->Le(ray);
             }
-            else
-                Li = light->Le(ray);
             if (!Li.IsBlack()) {
-                Li *= renderer->Transmittance(scene, ray, NULL, rng, arena);
+                if (qr) {
+                  qr->isLightVisible = true;
+                }
+                Spectrum transmittance = renderer->Transmittance(scene, ray, NULL, rng, arena);
+                Li *=  transmittance;
                 Ld += f * Li * AbsDot(wi, n) * weight / bsdfPdf;
+                Ld_diffuse += f_diffuse * Li * AbsDot(wi, n) * weight / bsdfPdf;
             }
         }
     }
+
+    if (qr) {
+      qr->diffuse_lighting = Ld_diffuse;
+    }
+
     return Ld;
 }
 
@@ -233,21 +276,21 @@
         
             float eta = bsdf->eta;
             Vector w = -wo;
-            if (Dot(w, n) < 0) eta = 1.f / eta;
+            if (Dot(wo, n) < 0) eta = 1.f / eta;
         
             Normal dndx = bsdf->dgShading.dndu * bsdf->dgShading.dudx + bsdf->dgShading.dndv * bsdf->dgShading.dvdx;
             Normal dndy = bsdf->dgShading.dndu * bsdf->dgShading.dudy + bsdf->dgShading.dndv * bsdf->dgShading.dvdy;
-
-            Vector dwdx = ray.rxDirection - w, dwdy = ray.ryDirection - w;
-            float dDNdx = Dot(dwdx, n) + Dot(w, dndx);
-            float dDNdy = Dot(dwdy, n) + Dot(w, dndy);
-
+        
+            Vector dwodx = -ray.rxDirection - wo, dwody = -ray.ryDirection - wo;
+            float dDNdx = Dot(dwodx, n) + Dot(wo, dndx);
+            float dDNdy = Dot(dwody, n) + Dot(wo, dndy);
+        
             float mu = eta * Dot(w, n) - Dot(wi, n);
             float dmudx = (eta - (eta*eta*Dot(w,n))/Dot(wi, n)) * dDNdx;
             float dmudy = (eta - (eta*eta*Dot(w,n))/Dot(wi, n)) * dDNdy;
         
-            rd.rxDirection = wi + eta * dwdx - Vector(mu * dndx + dmudx * n);
-            rd.ryDirection = wi + eta * dwdy - Vector(mu * dndy + dmudy * n);
+            rd.rxDirection = wi + eta * dwodx - Vector(mu * dndx + dmudx * n);
+            rd.ryDirection = wi + eta * dwody - Vector(mu * dndy + dmudy * n);
         }
         PBRT_STARTED_SPECULAR_REFRACTION_RAY(const_cast<RayDifferential *>(&rd));
         Spectrum Li = renderer->Li(scene, rd, sample, rng, arena);
diff -uarN pbrt/core/integrator.h rendernet_pbrt/core/integrator.h
--- pbrt/core/integrator.h	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/integrator.h	2019-09-07 01:14:54.000000000 +0000
@@ -43,6 +43,7 @@
 #include "light.h"
 #include "reflection.h"
 #include "sampler.h"
+#include "samplerecord.h"
 #include "material.h"
 #include "probes.h"
 #include "renderer.h"
@@ -67,6 +68,11 @@
     virtual Spectrum Li(const Scene *scene, const Renderer *renderer,
         const RayDifferential &ray, const Intersection &isect,
         const Sample *sample, RNG &rng, MemoryArena &arena) const = 0;
+    virtual RadianceQueryRecord RecordedLi(const Scene *scene, const Renderer *renderer,
+        const RayDifferential &ray, const Intersection &isect,
+        const Sample *sample, RNG &rng, MemoryArena &arena, SampleRecord *sw, 
+        Camera *camera) const {return RadianceQueryRecord(); };
+    virtual int maxDepth() { return 0; };
 };
 
 
@@ -80,12 +86,13 @@
     float rayEpsilon, float time, BSDF *bsdf,
     const Sample *sample, RNG &rng, int lightNumOffset = -1,
     const LightSampleOffsets *lightSampleOffset = NULL,
-    const BSDFSampleOffsets *bsdfSampleOffset = NULL);
+    const BSDFSampleOffsets *bsdfSampleOffset = NULL, 
+    LightQueryRecord *qr = NULL);
 Spectrum EstimateDirect(const Scene *scene, const Renderer *renderer,
     MemoryArena &arena, const Light *light, const Point &p,
     const Normal &n, const Vector &wo, float rayEpsilon, float time, const BSDF *bsdf,
     RNG &rng, const LightSample &lightSample, const BSDFSample &bsdfSample,
-    BxDFType flags);
+    BxDFType flags, LightQueryRecord *qr = NULL);
 Spectrum SpecularReflect(const RayDifferential &ray, BSDF *bsdf, RNG &rng,
     const Intersection &isect, const Renderer *renderer, const Scene *scene,
     const Sample *sample, MemoryArena &arena);
diff -uarN pbrt/core/pbrt.h rendernet_pbrt/core/pbrt.h
--- pbrt/core/pbrt.h	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/pbrt.h	2019-09-07 01:14:54.000000000 +0000
@@ -98,7 +98,12 @@
 #pragma warning (disable : 4305) // double constant assigned to float
 #pragma warning (disable : 4244) // int -> float conversion
 #pragma warning (disable : 4267) // size_t -> unsigned int conversion
-#endif
+#elif defined(PBRT_IS_APPLE)
+#else
+#include <cmath>
+#define isinf(f) (std::isinf((f)))
+#define isnan(f) (std::isnan((f)))
+#endif // PBRT_IS_WINDOWS
 
 #if defined(PBRT_IS_LINUX) || defined(PBRT_IS_APPLE)
 #include <stdint.h>
@@ -158,6 +163,7 @@
 class Camera;
 class ProjectiveCamera;
 class Sampler;
+class SampleRecord;
 struct CameraSample;
 struct Sample;
 class Filter;
diff -uarN pbrt/core/pbrtlex.cpp rendernet_pbrt/core/pbrtlex.cpp
--- pbrt/core/pbrtlex.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/pbrtlex.cpp	1970-01-01 00:00:00.000000000 +0000
@@ -1,2378 +0,0 @@
-#line 2 "core/pbrtlex.cpp"
-
-#line 4 "core/pbrtlex.cpp"
-
-#define  YY_INT_ALIGNED short int
-
-/* A lexical scanner generated by flex */
-
-#define FLEX_SCANNER
-#define YY_FLEX_MAJOR_VERSION 2
-#define YY_FLEX_MINOR_VERSION 5
-#define YY_FLEX_SUBMINOR_VERSION 35
-#if YY_FLEX_SUBMINOR_VERSION > 0
-#define FLEX_BETA
-#endif
-
-/* First, we deal with  platform-specific or compiler-specific issues. */
-
-/* begin standard C headers. */
-#include <stdio.h>
-#include <string.h>
-#include <errno.h>
-#include <stdlib.h>
-
-/* end standard C headers. */
-
-/* flex integer type definitions */
-
-#ifndef FLEXINT_H
-#define FLEXINT_H
-
-/* C99 systems have <inttypes.h>. Non-C99 systems may or may not. */
-
-#if defined (__STDC_VERSION__) && __STDC_VERSION__ >= 199901L
-
-/* C99 says to define __STDC_LIMIT_MACROS before including stdint.h,
- * if you want the limit (max/min) macros for int types. 
- */
-#ifndef __STDC_LIMIT_MACROS
-#define __STDC_LIMIT_MACROS 1
-#endif
-
-#include <inttypes.h>
-typedef int8_t flex_int8_t;
-typedef uint8_t flex_uint8_t;
-typedef int16_t flex_int16_t;
-typedef uint16_t flex_uint16_t;
-typedef int32_t flex_int32_t;
-typedef uint32_t flex_uint32_t;
-#else
-typedef signed char flex_int8_t;
-typedef short int flex_int16_t;
-typedef int flex_int32_t;
-typedef unsigned char flex_uint8_t; 
-typedef unsigned short int flex_uint16_t;
-typedef unsigned int flex_uint32_t;
-#endif /* ! C99 */
-
-/* Limits of integral types. */
-#ifndef INT8_MIN
-#define INT8_MIN               (-128)
-#endif
-#ifndef INT16_MIN
-#define INT16_MIN              (-32767-1)
-#endif
-#ifndef INT32_MIN
-#define INT32_MIN              (-2147483647-1)
-#endif
-#ifndef INT8_MAX
-#define INT8_MAX               (127)
-#endif
-#ifndef INT16_MAX
-#define INT16_MAX              (32767)
-#endif
-#ifndef INT32_MAX
-#define INT32_MAX              (2147483647)
-#endif
-#ifndef UINT8_MAX
-#define UINT8_MAX              (255U)
-#endif
-#ifndef UINT16_MAX
-#define UINT16_MAX             (65535U)
-#endif
-#ifndef UINT32_MAX
-#define UINT32_MAX             (4294967295U)
-#endif
-
-#endif /* ! FLEXINT_H */
-
-#ifdef __cplusplus
-
-/* The "const" storage-class-modifier is valid. */
-#define YY_USE_CONST
-
-#else	/* ! __cplusplus */
-
-/* C99 requires __STDC__ to be defined as 1. */
-#if defined (__STDC__)
-
-#define YY_USE_CONST
-
-#endif	/* defined (__STDC__) */
-#endif	/* ! __cplusplus */
-
-#ifdef YY_USE_CONST
-#define yyconst const
-#else
-#define yyconst
-#endif
-
-/* Returned upon end-of-file. */
-#define YY_NULL 0
-
-/* Promotes a possibly negative, possibly signed char to an unsigned
- * integer for use as an array index.  If the signed char is negative,
- * we want to instead treat it as an 8-bit unsigned char, hence the
- * double cast.
- */
-#define YY_SC_TO_UI(c) ((unsigned int) (unsigned char) c)
-
-/* Enter a start condition.  This macro really ought to take a parameter,
- * but we do it the disgusting crufty way forced on us by the ()-less
- * definition of BEGIN.
- */
-#define BEGIN (yy_start) = 1 + 2 *
-
-/* Translate the current start state into a value that can be later handed
- * to BEGIN to return to the state.  The YYSTATE alias is for lex
- * compatibility.
- */
-#define YY_START (((yy_start) - 1) / 2)
-#define YYSTATE YY_START
-
-/* Action number for EOF rule of a given start state. */
-#define YY_STATE_EOF(state) (YY_END_OF_BUFFER + state + 1)
-
-/* Special action meaning "start processing a new file". */
-#define YY_NEW_FILE yyrestart(yyin  )
-
-#define YY_END_OF_BUFFER_CHAR 0
-
-/* Size of default input buffer. */
-#ifndef YY_BUF_SIZE
-#define YY_BUF_SIZE 16384
-#endif
-
-/* The state buf must be large enough to hold one state per character in the main buffer.
- */
-#define YY_STATE_BUF_SIZE   ((YY_BUF_SIZE + 2) * sizeof(yy_state_type))
-
-#ifndef YY_TYPEDEF_YY_BUFFER_STATE
-#define YY_TYPEDEF_YY_BUFFER_STATE
-typedef struct yy_buffer_state *YY_BUFFER_STATE;
-#endif
-
-#ifndef YY_TYPEDEF_YY_SIZE_T
-#define YY_TYPEDEF_YY_SIZE_T
-typedef size_t yy_size_t;
-#endif
-
-extern yy_size_t yyleng;
-
-extern FILE *yyin, *yyout;
-
-#define EOB_ACT_CONTINUE_SCAN 0
-#define EOB_ACT_END_OF_FILE 1
-#define EOB_ACT_LAST_MATCH 2
-
-    #define YY_LESS_LINENO(n)
-    
-/* Return all but the first "n" matched characters back to the input stream. */
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		*yy_cp = (yy_hold_char); \
-		YY_RESTORE_YY_MORE_OFFSET \
-		(yy_c_buf_p) = yy_cp = yy_bp + yyless_macro_arg - YY_MORE_ADJ; \
-		YY_DO_BEFORE_ACTION; /* set up yytext again */ \
-		} \
-	while ( 0 )
-
-#define unput(c) yyunput( c, (yytext_ptr)  )
-
-#ifndef YY_STRUCT_YY_BUFFER_STATE
-#define YY_STRUCT_YY_BUFFER_STATE
-struct yy_buffer_state
-	{
-	FILE *yy_input_file;
-
-	char *yy_ch_buf;		/* input buffer */
-	char *yy_buf_pos;		/* current position in input buffer */
-
-	/* Size of input buffer in bytes, not including room for EOB
-	 * characters.
-	 */
-	yy_size_t yy_buf_size;
-
-	/* Number of characters read into yy_ch_buf, not including EOB
-	 * characters.
-	 */
-	yy_size_t yy_n_chars;
-
-	/* Whether we "own" the buffer - i.e., we know we created it,
-	 * and can realloc() it to grow it, and should free() it to
-	 * delete it.
-	 */
-	int yy_is_our_buffer;
-
-	/* Whether this is an "interactive" input source; if so, and
-	 * if we're using stdio for input, then we want to use getc()
-	 * instead of fread(), to make sure we stop fetching input after
-	 * each newline.
-	 */
-	int yy_is_interactive;
-
-	/* Whether we're considered to be at the beginning of a line.
-	 * If so, '^' rules will be active on the next match, otherwise
-	 * not.
-	 */
-	int yy_at_bol;
-
-    int yy_bs_lineno; /**< The line count. */
-    int yy_bs_column; /**< The column count. */
-    
-	/* Whether to try to fill the input buffer when we reach the
-	 * end of it.
-	 */
-	int yy_fill_buffer;
-
-	int yy_buffer_status;
-
-#define YY_BUFFER_NEW 0
-#define YY_BUFFER_NORMAL 1
-	/* When an EOF's been seen but there's still some text to process
-	 * then we mark the buffer as YY_EOF_PENDING, to indicate that we
-	 * shouldn't try reading from the input source any more.  We might
-	 * still have a bunch of tokens to match, though, because of
-	 * possible backing-up.
-	 *
-	 * When we actually see the EOF, we change the status to "new"
-	 * (via yyrestart()), so that the user can continue scanning by
-	 * just pointing yyin at a new input file.
-	 */
-#define YY_BUFFER_EOF_PENDING 2
-
-	};
-#endif /* !YY_STRUCT_YY_BUFFER_STATE */
-
-/* Stack of input buffers. */
-static size_t yy_buffer_stack_top = 0; /**< index of top of stack. */
-static size_t yy_buffer_stack_max = 0; /**< capacity of stack. */
-static YY_BUFFER_STATE * yy_buffer_stack = 0; /**< Stack as an array. */
-
-/* We provide macros for accessing buffer states in case in the
- * future we want to put the buffer states in a more general
- * "scanner state".
- *
- * Returns the top of the stack, or NULL.
- */
-#define YY_CURRENT_BUFFER ( (yy_buffer_stack) \
-                          ? (yy_buffer_stack)[(yy_buffer_stack_top)] \
-                          : NULL)
-
-/* Same as previous macro, but useful when we know that the buffer stack is not
- * NULL or when we need an lvalue. For internal use only.
- */
-#define YY_CURRENT_BUFFER_LVALUE (yy_buffer_stack)[(yy_buffer_stack_top)]
-
-/* yy_hold_char holds the character lost when yytext is formed. */
-static char yy_hold_char;
-static yy_size_t yy_n_chars;		/* number of characters read into yy_ch_buf */
-yy_size_t yyleng;
-
-/* Points to current character in buffer. */
-static char *yy_c_buf_p = (char *) 0;
-static int yy_init = 0;		/* whether we need to initialize */
-static int yy_start = 0;	/* start state number */
-
-/* Flag which is used to allow yywrap()'s to do buffer switches
- * instead of setting up a fresh yyin.  A bit of a hack ...
- */
-static int yy_did_buffer_switch_on_eof;
-
-void yyrestart (FILE *input_file  );
-void yy_switch_to_buffer (YY_BUFFER_STATE new_buffer  );
-YY_BUFFER_STATE yy_create_buffer (FILE *file,int size  );
-void yy_delete_buffer (YY_BUFFER_STATE b  );
-void yy_flush_buffer (YY_BUFFER_STATE b  );
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer  );
-void yypop_buffer_state (void );
-
-static void yyensure_buffer_stack (void );
-static void yy_load_buffer_state (void );
-static void yy_init_buffer (YY_BUFFER_STATE b,FILE *file  );
-
-#define YY_FLUSH_BUFFER yy_flush_buffer(YY_CURRENT_BUFFER )
-
-YY_BUFFER_STATE yy_scan_buffer (char *base,yy_size_t size  );
-YY_BUFFER_STATE yy_scan_string (yyconst char *yy_str  );
-YY_BUFFER_STATE yy_scan_bytes (yyconst char *bytes,yy_size_t len  );
-
-void *yyalloc (yy_size_t  );
-void *yyrealloc (void *,yy_size_t  );
-void yyfree (void *  );
-
-#define yy_new_buffer yy_create_buffer
-
-#define yy_set_interactive(is_interactive) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){ \
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_is_interactive = is_interactive; \
-	}
-
-#define yy_set_bol(at_bol) \
-	{ \
-	if ( ! YY_CURRENT_BUFFER ){\
-        yyensure_buffer_stack (); \
-		YY_CURRENT_BUFFER_LVALUE =    \
-            yy_create_buffer(yyin,YY_BUF_SIZE ); \
-	} \
-	YY_CURRENT_BUFFER_LVALUE->yy_at_bol = at_bol; \
-	}
-
-#define YY_AT_BOL() (YY_CURRENT_BUFFER_LVALUE->yy_at_bol)
-
-/* Begin user sect3 */
-
-typedef unsigned char YY_CHAR;
-
-FILE *yyin = (FILE *) 0, *yyout = (FILE *) 0;
-
-typedef int yy_state_type;
-
-extern int yylineno;
-
-int yylineno = 1;
-
-extern char *yytext;
-#define yytext_ptr yytext
-
-static yy_state_type yy_get_previous_state (void );
-static yy_state_type yy_try_NUL_trans (yy_state_type current_state  );
-static int yy_get_next_buffer (void );
-static void yy_fatal_error (yyconst char msg[]  );
-
-/* Done after the current pattern has been matched and before the
- * corresponding action - sets up yytext.
- */
-#define YY_DO_BEFORE_ACTION \
-	(yytext_ptr) = yy_bp; \
-	yyleng = (size_t) (yy_cp - yy_bp); \
-	(yy_hold_char) = *yy_cp; \
-	*yy_cp = '\0'; \
-	(yy_c_buf_p) = yy_cp;
-
-#define YY_NUM_RULES 66
-#define YY_END_OF_BUFFER 67
-/* This struct is not used in this scanner,
-   but its presence is necessary. */
-struct yy_trans_info
-	{
-	flex_int32_t yy_verify;
-	flex_int32_t yy_nxt;
-	};
-static yyconst flex_int16_t yy_accept[394] =
-    {   0,
-        0,    0,    0,    0,    0,    0,    0,    0,    0,    0,
-       67,   65,   45,   46,   51,    1,   65,   65,   47,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   49,   50,   63,   64,   62,
-       63,    2,    3,   66,   45,    0,   47,   47,   47,    0,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   61,   60,
-       57,   61,   58,   55,   56,   52,   54,   53,   47,    0,
-       47,   48,   48,    6,   48,   48,   48,   48,   48,   48,
-
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,    0,   48,   48,   48,   48,   48,   48,   48,
-       48,   15,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   59,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   31,   32,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   10,   48,   48,
-       48,   48,   48,   48,   48,   19,   48,   48,   48,   48,
-
-       48,   48,   48,   29,   48,   48,   48,   48,   48,   48,
-       41,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-       14,   48,   17,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   48,   30,   48,   48,   35,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   16,
-       48,   48,   21,   48,   48,   48,   48,   48,   27,   48,
-       48,   48,   48,   48,   48,   48,   44,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   24,   48,
-       48,   48,   33,   48,   39,   40,   48,   48,   48,   48,
-       48,   48,   48,   48,   48,   48,   48,   48,   48,   48,
-
-       48,   48,   48,   48,   48,   48,   48,   48,   43,    4,
-       48,   48,   48,   48,   48,   48,   48,   18,   48,   48,
-       23,   48,   26,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,    9,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   37,   48,   48,   48,   48,   48,   48,   48,
-       48,   48,   22,   48,   48,   48,   48,   48,   48,   48,
-       48,    8,   48,   48,   48,   48,   25,   48,   48,   36,
-       38,   48,    5,    7,   11,   48,   48,   48,   48,   48,
-       48,   48,   12,   48,   48,   48,   42,   13,   20,   48,
-       34,   28,    0
-
-    } ;
-
-static yyconst flex_int32_t yy_ec[256] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    2,    3,
-        1,    1,    2,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    2,    1,    4,    5,    1,    1,    1,    1,    1,
-        1,    1,    6,    1,    6,    7,    1,    8,    8,    8,
-        8,    8,    8,    8,    8,    8,    8,    1,    1,    1,
-        1,    1,    1,    1,    9,   10,   11,   12,   13,   14,
-       12,   12,   15,   12,   12,   16,   17,   18,   19,   20,
-       12,   21,   22,   23,   12,   24,   25,   12,   12,   12,
-       26,   27,   28,    1,   12,    1,   29,   30,   31,   32,
-
-       33,   34,   35,   36,   37,   38,   39,   40,   41,   42,
-       43,   44,   12,   45,   46,   47,   48,   49,   12,   50,
-       51,   12,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1
-    } ;
-
-static yyconst flex_int32_t yy_meta[52] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    2,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
-        2,    2,    2,    2,    2,    1,    1,    1,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
-        2,    2,    2,    2,    2,    2,    2,    2,    2,    2,
-        2
-    } ;
-
-static yyconst flex_int16_t yy_base[399] =
-    {   0,
-        0,    0,   49,   51,  430,  429,    0,    0,    0,    0,
-      431,  434,  428,  434,  434,  434,   49,  421,   51,   30,
-        0,   31,  386,  390,   30,   26,  397,  396,  394,  386,
-       38,   51,   34,  379,  378,  434,  434,  434,  434,  434,
-       97,  434,  434,  434,  418,  411,   78,   60,   75,   84,
-        0,   63,  378,  384,  369,  374,   23,  382,  373,  379,
-      380,  375,  366,   50,  367,  369,  356,   53,  358,  363,
-      374,  373,  372,  355,  349,  369,  357,  351,  434,  434,
-      434,  387,  434,  434,  434,  434,  434,  434,   96,  386,
-      385,  359,  354,    0,  361,  344,  355,  356,  341,  362,
-
-      343,  341,  342,  345,  341,  346,  345,  344,  343,  342,
-      342,  340,  343,  327,  330,  325,  323,  333,  319,  323,
-      316,  323,  354,  321,  311,  343,  321,  312,  327,  323,
-      317,    0,  306,  304,  304,  341,  331,  303,  315,  315,
-      305,  311,  298,  295,  301,  307,  306,  291,  308,  288,
-      289,  293,  301,  434,  299,  298,  293,  299,  299,  280,
-       81,  285,  288,  292,  301,  275,  292,  283,  302,  271,
-      303,  271,  269,  281,  280,    0,    0,  289,  280,  265,
-       72,  276,  103,  263,  284,  271,  257,    0,  281,  252,
-      260,  268,  253,  266,  255,    0,  256,  267,  266,  104,
-
-      257,  260,  259,    0,  246,  253,  256,  255,  244,  257,
-      270,  251,  241,  253,  236,  244,  232,  233,  231,  247,
-        0,  224,    0,  226,  240,  232,  224,  237,  227,  226,
-      227,  221,  246,    0,  223,  248,    0,  217,  214,  218,
-      224,  226,  210,  227,  208,  221,  224,  229,  204,    0,
-      205,  217,    0,  215,  212,  214,  199,  197,    0,  198,
-      209,  199,  199,  206,  191,  200,    0,  193,  193,  212,
-      110,  191,  187,  198,  199,  212,  183,  190,    0,  179,
-      192,  187,    0,  176,  112,    0,  189,  179,  175,  173,
-      175,  184,  174,  169,  185,  191,  179,  182,  173,  167,
-
-      179,  162,  173,  172,  171,  161,  165,  166,    0,    0,
-      166,  151,  163,  165,  162,  153,  143,    0,  146,  163,
-        0,  149,    0,  148,  154,  153,  155,  145,  140,  141,
-      138,  145,    0,  138,  134,  133,  145,  137,  145,  128,
-      129,  136,    0,  139,  142,  125,  138,  126,  122,  132,
-      118,  119,    0,  130,  133,  132,  118,  113,  111,  116,
-      123,    0,  114,  111,  120,  106,    0,   94,   93,    0,
-        0,   95,    0,    0,    0,   92,   95,  105,   96,   89,
-       85,   87,    0,   86,   78,   70,    0,    0,    0,   65,
-        0,    0,  434,  144,  146,  148,   94,  150
-
-    } ;
-
-static yyconst flex_int16_t yy_def[399] =
-    {   0,
-      393,    1,  394,  394,  395,  395,  396,  396,  396,  396,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  393,  393,  393,  393,  393,
-      398,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  393,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  393,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,  397,  397,  397,  397,  397,  397,  397,  397,
-      397,  397,    0,  393,  393,  393,  393,  393
-
-    } ;
-
-static yyconst flex_int16_t yy_nxt[486] =
-    {   0,
-       12,   13,   14,   15,   16,   17,   18,   19,   20,   21,
-       22,   21,   23,   24,   25,   26,   27,   28,   29,   30,
-       31,   32,   33,   34,   35,   36,   12,   37,   21,   21,
-       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
-       21,   21,   21,   21,   21,   21,   21,   21,   21,   21,
-       21,   39,   40,   39,   40,   46,   47,   49,   47,   56,
-       52,   60,   62,   50,   98,   99,   75,   48,   63,   53,
-       68,   61,   50,   57,   54,   41,   55,   41,   76,   70,
-       69,   71,   89,   50,   49,   47,   72,   50,  106,   90,
-       50,   91,   50,   92,  111,   51,  107,   73,   74,   80,
-
-       81,  112,  190,   89,   82,  209,  392,   50,   50,   93,
-       50,  210,  212,  228,  391,  213,  229,  191,  230,  292,
-      390,  305,  293,   83,  306,  389,   84,  388,   50,  387,
-       85,  386,  385,  384,  307,  383,  382,  381,   86,  380,
-      379,   87,  378,   88,   38,   38,   42,   42,   44,   44,
-       79,   79,  377,  376,  375,  374,  373,  372,  371,  370,
-      369,  368,  367,  366,  365,  364,  363,  362,  361,  360,
-      359,  358,  357,  356,  355,  354,  353,  352,  351,  350,
-      349,  348,  347,  346,  345,  344,  343,  342,  341,  340,
-      339,  338,  337,  336,  335,  334,  333,  332,  331,  330,
-
-      329,  328,  327,  326,  325,  324,  323,  322,  321,  320,
-      319,  318,  317,  316,  315,  314,  313,  312,  311,  310,
-      309,  308,  304,  303,  302,  301,  300,  299,  298,  297,
-      296,  295,  294,  291,  290,  289,  288,  287,  286,  285,
-      284,  283,  282,  281,  280,  279,  278,  277,  276,  275,
-      274,  273,  272,  271,  270,  269,  268,  267,  266,  265,
-      264,  263,  262,  261,  260,  259,  258,  257,  256,  255,
-      254,  253,  252,  251,  250,  249,  248,  247,  246,  245,
-      244,  243,  242,  241,  240,  239,  238,  237,  236,  235,
-      234,  233,  232,  231,  227,  226,  225,  224,  223,  222,
-
-      221,  220,  219,  218,  217,  216,  215,  214,  211,  208,
-      207,  206,  205,  204,  203,  202,  201,  200,  199,  198,
-      197,  196,  195,  194,  193,  192,  189,  188,  187,  186,
-      185,  184,  183,  182,  181,  180,  179,  178,  177,  176,
-      175,  174,  173,  172,  171,  170,  169,  168,  167,  166,
-      165,  164,  163,  162,  161,  160,  159,  158,  157,  156,
-      155,  154,  153,  152,  151,  150,  149,  148,  147,  146,
-      145,  144,  143,  142,  141,  140,  139,  138,  137,  136,
-      135,  134,  133,  132,  131,  130,  129,  128,  127,  126,
-      125,  124,   91,   91,  123,  122,  121,  120,  119,  118,
-
-      117,  116,  115,  114,  113,  110,  109,  108,  105,  104,
-      103,  102,  101,  100,   97,   96,   95,   94,   48,   45,
-       78,   77,   67,   66,   65,   64,   59,   58,   48,   45,
-      393,   43,   43,   11,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393
-    } ;
-
-static yyconst flex_int16_t yy_chk[486] =
-    {   0,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    1,    1,    1,    1,    1,    1,    1,    1,    1,
-        1,    3,    3,    4,    4,   17,   17,   19,   19,   22,
-       20,   25,   26,   19,   57,   57,   33,   48,   26,   20,
-       31,   25,   48,   22,   20,    3,   20,    4,   33,   32,
-       31,   32,   49,   19,   47,   47,   32,   49,   64,   50,
-       47,   50,   48,   52,   68,  397,   64,   32,   32,   41,
-
-       41,   68,  161,   89,   41,  181,  390,   49,   89,   52,
-       47,  181,  183,  200,  386,  183,  200,  161,  200,  271,
-      385,  285,  271,   41,  285,  384,   41,  382,   89,  381,
-       41,  380,  379,  378,  285,  377,  376,  372,   41,  369,
-      368,   41,  366,   41,  394,  394,  395,  395,  396,  396,
-      398,  398,  365,  364,  363,  361,  360,  359,  358,  357,
-      356,  355,  354,  352,  351,  350,  349,  348,  347,  346,
-      345,  344,  342,  341,  340,  339,  338,  337,  336,  335,
-      334,  332,  331,  330,  329,  328,  327,  326,  325,  324,
-      322,  320,  319,  317,  316,  315,  314,  313,  312,  311,
-
-      308,  307,  306,  305,  304,  303,  302,  301,  300,  299,
-      298,  297,  296,  295,  294,  293,  292,  291,  290,  289,
-      288,  287,  284,  282,  281,  280,  278,  277,  276,  275,
-      274,  273,  272,  270,  269,  268,  266,  265,  264,  263,
-      262,  261,  260,  258,  257,  256,  255,  254,  252,  251,
-      249,  248,  247,  246,  245,  244,  243,  242,  241,  240,
-      239,  238,  236,  235,  233,  232,  231,  230,  229,  228,
-      227,  226,  225,  224,  222,  220,  219,  218,  217,  216,
-      215,  214,  213,  212,  211,  210,  209,  208,  207,  206,
-      205,  203,  202,  201,  199,  198,  197,  195,  194,  193,
-
-      192,  191,  190,  189,  187,  186,  185,  184,  182,  180,
-      179,  178,  175,  174,  173,  172,  171,  170,  169,  168,
-      167,  166,  165,  164,  163,  162,  160,  159,  158,  157,
-      156,  155,  153,  152,  151,  150,  149,  148,  147,  146,
-      145,  144,  143,  142,  141,  140,  139,  138,  137,  136,
-      135,  134,  133,  131,  130,  129,  128,  127,  126,  125,
-      124,  123,  122,  121,  120,  119,  118,  117,  116,  115,
-      114,  113,  112,  111,  110,  109,  108,  107,  106,  105,
-      104,  103,  102,  101,  100,   99,   98,   97,   96,   95,
-       93,   92,   91,   90,   82,   78,   77,   76,   75,   74,
-
-       73,   72,   71,   70,   69,   67,   66,   65,   63,   62,
-       61,   60,   59,   58,   56,   55,   54,   53,   46,   45,
-       35,   34,   30,   29,   28,   27,   24,   23,   18,   13,
-       11,    6,    5,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393,  393,  393,  393,  393,  393,
-      393,  393,  393,  393,  393
-    } ;
-
-static yy_state_type yy_last_accepting_state;
-static char *yy_last_accepting_cpos;
-
-extern int yy_flex_debug;
-int yy_flex_debug = 0;
-
-/* The intent behind this definition is that it'll catch
- * any uses of REJECT which flex missed.
- */
-#define REJECT reject_used_but_not_detected
-#define yymore() yymore_used_but_not_detected
-#define YY_MORE_ADJ 0
-#define YY_RESTORE_YY_MORE_OFFSET
-char *yytext;
-#line 1 "core/pbrtlex.ll"
-/*
-    pbrt source code Copyright(c) 1998-2010 Matt Pharr and Greg Humphreys.
-
-    This file is part of pbrt.
-
-    Redistribution and use in source and binary forms, with or without
-    modification, are permitted provided that the following conditions are
-    met:
-
-    - Redistributions of source code must retain the above copyright
-      notice, this list of conditions and the following disclaimer.
-
-    - Redistributions in binary form must reproduce the above copyright
-      notice, this list of conditions and the following disclaimer in the
-      documentation and/or other materials provided with the distribution.
-
-    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
-    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
-    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
-    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
-    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
-    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
-    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
-    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
- */
-/* state used for include file stuff */
-#line 26 "core/pbrtlex.ll"
-
-#define YY_MAIN 0
-#define YY_NEVER_INTERACTIVE 1
-
-#include "pbrt.h"
-#include "api.h"
-#include "fileutil.h"
-
-struct ParamArray;
-
-#if defined(PBRT_IS_WINDOWS)
-#pragma warning(disable:4244)
-#pragma warning(disable:4065)
-#pragma warning(disable:4018)
-#pragma warning(disable:4996)
-#endif
-#include "pbrtparse.hh"
-
-struct IncludeInfo {
-    string filename;
-    YY_BUFFER_STATE bufState;
-    int lineNum;
-};
-
-
-vector<IncludeInfo> includeStack;
-
-extern int line_num;
-int str_pos;
-
-void add_string_char(char c) {
-    yylval.string[str_pos++] = c;
-    yylval.string[str_pos] = '\0';
-}
-
-
-void include_push(char *filename) {
-    if (includeStack.size() > 32)
-        Severe("Only 32 levels of nested Include allowed in scene files.");
-    IncludeInfo ii;
-    extern string current_file;
-    ii.filename = current_file;
-    ii.bufState = YY_CURRENT_BUFFER;
-    ii.lineNum = line_num;
-    includeStack.push_back(ii);
-
-    current_file = AbsolutePath(ResolveFilename(filename));
-    line_num = 1;
-
-    yyin = fopen(current_file.c_str(), "r");
-    if (!yyin)
-        Severe("Unable to open included scene file \"%s\"", current_file.c_str());
-    yy_switch_to_buffer(yy_create_buffer(yyin,YY_BUF_SIZE));
-}
-
-
-
-void include_pop() {
-    extern int line_num;
-    extern string current_file;
-    fclose(yyin);
-    yy_delete_buffer(YY_CURRENT_BUFFER);
-    yy_switch_to_buffer(includeStack.back().bufState);
-    current_file = includeStack.back().filename;
-    line_num = includeStack.back().lineNum;
-    includeStack.pop_back();
-}
-
-
-
-#line 781 "core/pbrtlex.cpp"
-
-#define INITIAL 0
-#define STR 1
-#define COMMENT 2
-#define INCL 3
-#define INCL_FILE 4
-
-#ifndef YY_NO_UNISTD_H
-/* Special case for "unistd.h", since it is non-ANSI. We include it way
- * down here because we want the user's section 1 to have been scanned first.
- * The user has a chance to override it with an option.
- */
-#include <unistd.h>
-#endif
-
-#ifndef YY_EXTRA_TYPE
-#define YY_EXTRA_TYPE void *
-#endif
-
-static int yy_init_globals (void );
-
-/* Accessor methods to globals.
-   These are made visible to non-reentrant scanners for convenience. */
-
-int yylex_destroy (void );
-
-int yyget_debug (void );
-
-void yyset_debug (int debug_flag  );
-
-YY_EXTRA_TYPE yyget_extra (void );
-
-void yyset_extra (YY_EXTRA_TYPE user_defined  );
-
-FILE *yyget_in (void );
-
-void yyset_in  (FILE * in_str  );
-
-FILE *yyget_out (void );
-
-void yyset_out  (FILE * out_str  );
-
-yy_size_t yyget_leng (void );
-
-char *yyget_text (void );
-
-int yyget_lineno (void );
-
-void yyset_lineno (int line_number  );
-
-/* Macros after this point can all be overridden by user definitions in
- * section 1.
- */
-
-#ifndef YY_SKIP_YYWRAP
-#ifdef __cplusplus
-extern "C" int yywrap (void );
-#else
-extern int yywrap (void );
-#endif
-#endif
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char *,yyconst char *,int );
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * );
-#endif
-
-#ifndef YY_NO_INPUT
-
-#ifdef __cplusplus
-static int yyinput (void );
-#else
-static int input (void );
-#endif
-
-#endif
-
-/* Amount of stuff to slurp up with each read. */
-#ifndef YY_READ_BUF_SIZE
-#define YY_READ_BUF_SIZE 8192
-#endif
-
-/* Copy whatever the last rule matched to the standard output. */
-#ifndef ECHO
-/* This used to be an fputs(), but since the string might contain NUL's,
- * we now use fwrite().
- */
-#define ECHO fwrite( yytext, yyleng, 1, yyout )
-#endif
-
-/* Gets input and stuffs it into "buf".  number of characters read, or YY_NULL,
- * is returned in "result".
- */
-#ifndef YY_INPUT
-#define YY_INPUT(buf,result,max_size) \
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_is_interactive ) \
-		{ \
-		int c = '*'; \
-		yy_size_t n; \
-		for ( n = 0; n < max_size && \
-			     (c = getc( yyin )) != EOF && c != '\n'; ++n ) \
-			buf[n] = (char) c; \
-		if ( c == '\n' ) \
-			buf[n++] = (char) c; \
-		if ( c == EOF && ferror( yyin ) ) \
-			YY_FATAL_ERROR( "input in flex scanner failed" ); \
-		result = n; \
-		} \
-	else \
-		{ \
-		errno=0; \
-		while ( (result = fread(buf, 1, max_size, yyin))==0 && ferror(yyin)) \
-			{ \
-			if( errno != EINTR) \
-				{ \
-				YY_FATAL_ERROR( "input in flex scanner failed" ); \
-				break; \
-				} \
-			errno=0; \
-			clearerr(yyin); \
-			} \
-		}\
-\
-
-#endif
-
-/* No semi-colon after return; correct usage is to write "yyterminate();" -
- * we don't want an extra ';' after the "return" because that will cause
- * some compilers to complain about unreachable statements.
- */
-#ifndef yyterminate
-#define yyterminate() return YY_NULL
-#endif
-
-/* Number of entries by which start-condition stack grows. */
-#ifndef YY_START_STACK_INCR
-#define YY_START_STACK_INCR 25
-#endif
-
-/* Report a fatal error. */
-#ifndef YY_FATAL_ERROR
-#define YY_FATAL_ERROR(msg) yy_fatal_error( msg )
-#endif
-
-/* end tables serialization structures and prototypes */
-
-/* Default declaration of generated scanner - a define so the user can
- * easily add parameters.
- */
-#ifndef YY_DECL
-#define YY_DECL_IS_OURS 1
-
-extern int yylex (void);
-
-#define YY_DECL int yylex (void)
-#endif /* !YY_DECL */
-
-/* Code executed at the beginning of each rule, after yytext and yyleng
- * have been set up.
- */
-#ifndef YY_USER_ACTION
-#define YY_USER_ACTION
-#endif
-
-/* Code executed at the end of each rule. */
-#ifndef YY_BREAK
-#define YY_BREAK break;
-#endif
-
-#define YY_RULE_SETUP \
-	YY_USER_ACTION
-
-/** The main scanner function which does all the work.
- */
-YY_DECL
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp, *yy_bp;
-	register int yy_act;
-    
-#line 101 "core/pbrtlex.ll"
-
-
-#line 968 "core/pbrtlex.cpp"
-
-	if ( !(yy_init) )
-		{
-		(yy_init) = 1;
-
-#ifdef YY_USER_INIT
-		YY_USER_INIT;
-#endif
-
-		if ( ! (yy_start) )
-			(yy_start) = 1;	/* first start state */
-
-		if ( ! yyin )
-			yyin = stdin;
-
-		if ( ! yyout )
-			yyout = stdout;
-
-		if ( ! YY_CURRENT_BUFFER ) {
-			yyensure_buffer_stack ();
-			YY_CURRENT_BUFFER_LVALUE =
-				yy_create_buffer(yyin,YY_BUF_SIZE );
-		}
-
-		yy_load_buffer_state( );
-		}
-
-	while ( 1 )		/* loops until end-of-file is reached */
-		{
-		yy_cp = (yy_c_buf_p);
-
-		/* Support of yytext. */
-		*yy_cp = (yy_hold_char);
-
-		/* yy_bp points to the position in yy_ch_buf of the start of
-		 * the current run.
-		 */
-		yy_bp = yy_cp;
-
-		yy_current_state = (yy_start);
-yy_match:
-		do
-			{
-			register YY_CHAR yy_c = yy_ec[YY_SC_TO_UI(*yy_cp)];
-			if ( yy_accept[yy_current_state] )
-				{
-				(yy_last_accepting_state) = yy_current_state;
-				(yy_last_accepting_cpos) = yy_cp;
-				}
-			while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-				{
-				yy_current_state = (int) yy_def[yy_current_state];
-				if ( yy_current_state >= 394 )
-					yy_c = yy_meta[(unsigned int) yy_c];
-				}
-			yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-			++yy_cp;
-			}
-		while ( yy_base[yy_current_state] != 434 );
-
-yy_find_action:
-		yy_act = yy_accept[yy_current_state];
-		if ( yy_act == 0 )
-			{ /* have to back up */
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			yy_act = yy_accept[yy_current_state];
-			}
-
-		YY_DO_BEFORE_ACTION;
-
-do_action:	/* This label is used only to access EOF actions. */
-
-		switch ( yy_act )
-	{ /* beginning of action switch */
-			case 0: /* must back up */
-			/* undo the effects of YY_DO_BEFORE_ACTION */
-			*yy_cp = (yy_hold_char);
-			yy_cp = (yy_last_accepting_cpos);
-			yy_current_state = (yy_last_accepting_state);
-			goto yy_find_action;
-
-case 1:
-YY_RULE_SETUP
-#line 103 "core/pbrtlex.ll"
-{ BEGIN COMMENT; }
-	YY_BREAK
-case 2:
-YY_RULE_SETUP
-#line 104 "core/pbrtlex.ll"
-/* eat it up */
-	YY_BREAK
-case 3:
-/* rule 3 can match eol */
-YY_RULE_SETUP
-#line 105 "core/pbrtlex.ll"
-{ line_num++; BEGIN INITIAL; }
-	YY_BREAK
-case 4:
-YY_RULE_SETUP
-#line 106 "core/pbrtlex.ll"
-{ return ACCELERATOR; }
-	YY_BREAK
-case 5:
-YY_RULE_SETUP
-#line 107 "core/pbrtlex.ll"
-{ return ACTIVETRANSFORM; }
-	YY_BREAK
-case 6:
-YY_RULE_SETUP
-#line 108 "core/pbrtlex.ll"
-{ return ALL; }
-	YY_BREAK
-case 7:
-YY_RULE_SETUP
-#line 109 "core/pbrtlex.ll"
-{ return AREALIGHTSOURCE; }
-	YY_BREAK
-case 8:
-YY_RULE_SETUP
-#line 110 "core/pbrtlex.ll"
-{ return ATTRIBUTEBEGIN; }
-	YY_BREAK
-case 9:
-YY_RULE_SETUP
-#line 111 "core/pbrtlex.ll"
-{ return ATTRIBUTEEND; }
-	YY_BREAK
-case 10:
-YY_RULE_SETUP
-#line 112 "core/pbrtlex.ll"
-{ return CAMERA; }
-	YY_BREAK
-case 11:
-YY_RULE_SETUP
-#line 113 "core/pbrtlex.ll"
-{ return CONCATTRANSFORM; }
-	YY_BREAK
-case 12:
-YY_RULE_SETUP
-#line 114 "core/pbrtlex.ll"
-{ return COORDINATESYSTEM; }
-	YY_BREAK
-case 13:
-YY_RULE_SETUP
-#line 115 "core/pbrtlex.ll"
-{ return COORDSYSTRANSFORM; }
-	YY_BREAK
-case 14:
-YY_RULE_SETUP
-#line 116 "core/pbrtlex.ll"
-{ return ENDTIME; }
-	YY_BREAK
-case 15:
-YY_RULE_SETUP
-#line 117 "core/pbrtlex.ll"
-{ return FILM; }
-	YY_BREAK
-case 16:
-YY_RULE_SETUP
-#line 118 "core/pbrtlex.ll"
-{ return IDENTITY; }
-	YY_BREAK
-case 17:
-YY_RULE_SETUP
-#line 119 "core/pbrtlex.ll"
-{ return INCLUDE; }
-	YY_BREAK
-case 18:
-YY_RULE_SETUP
-#line 120 "core/pbrtlex.ll"
-{ return LIGHTSOURCE; }
-	YY_BREAK
-case 19:
-YY_RULE_SETUP
-#line 121 "core/pbrtlex.ll"
-{ return LOOKAT; }
-	YY_BREAK
-case 20:
-YY_RULE_SETUP
-#line 122 "core/pbrtlex.ll"
-{ return MAKENAMEDMATERIAL; }
-	YY_BREAK
-case 21:
-YY_RULE_SETUP
-#line 123 "core/pbrtlex.ll"
-{ return MATERIAL; }
-	YY_BREAK
-case 22:
-YY_RULE_SETUP
-#line 124 "core/pbrtlex.ll"
-{ return NAMEDMATERIAL; }
-	YY_BREAK
-case 23:
-YY_RULE_SETUP
-#line 125 "core/pbrtlex.ll"
-{ return OBJECTBEGIN; }
-	YY_BREAK
-case 24:
-YY_RULE_SETUP
-#line 126 "core/pbrtlex.ll"
-{ return OBJECTEND; }
-	YY_BREAK
-case 25:
-YY_RULE_SETUP
-#line 127 "core/pbrtlex.ll"
-{ return OBJECTINSTANCE; }
-	YY_BREAK
-case 26:
-YY_RULE_SETUP
-#line 128 "core/pbrtlex.ll"
-{ return PIXELFILTER; }
-	YY_BREAK
-case 27:
-YY_RULE_SETUP
-#line 129 "core/pbrtlex.ll"
-{ return RENDERER; }
-	YY_BREAK
-case 28:
-YY_RULE_SETUP
-#line 130 "core/pbrtlex.ll"
-{ return REVERSEORIENTATION; }
-	YY_BREAK
-case 29:
-YY_RULE_SETUP
-#line 131 "core/pbrtlex.ll"
-{ return ROTATE; }
-	YY_BREAK
-case 30:
-YY_RULE_SETUP
-#line 132 "core/pbrtlex.ll"
-{ return SAMPLER; }
-	YY_BREAK
-case 31:
-YY_RULE_SETUP
-#line 133 "core/pbrtlex.ll"
-{ return SCALE; }
-	YY_BREAK
-case 32:
-YY_RULE_SETUP
-#line 134 "core/pbrtlex.ll"
-{ return SHAPE; }
-	YY_BREAK
-case 33:
-YY_RULE_SETUP
-#line 135 "core/pbrtlex.ll"
-{ return STARTTIME; }
-	YY_BREAK
-case 34:
-YY_RULE_SETUP
-#line 136 "core/pbrtlex.ll"
-{ return SURFACEINTEGRATOR; }
-	YY_BREAK
-case 35:
-YY_RULE_SETUP
-#line 137 "core/pbrtlex.ll"
-{ return TEXTURE; }
-	YY_BREAK
-case 36:
-YY_RULE_SETUP
-#line 138 "core/pbrtlex.ll"
-{ return TRANSFORMBEGIN; }
-	YY_BREAK
-case 37:
-YY_RULE_SETUP
-#line 139 "core/pbrtlex.ll"
-{ return TRANSFORMEND; }
-	YY_BREAK
-case 38:
-YY_RULE_SETUP
-#line 140 "core/pbrtlex.ll"
-{ return TRANSFORMTIMES; }
-	YY_BREAK
-case 39:
-YY_RULE_SETUP
-#line 141 "core/pbrtlex.ll"
-{ return TRANSFORM; }
-	YY_BREAK
-case 40:
-YY_RULE_SETUP
-#line 142 "core/pbrtlex.ll"
-{ return TRANSLATE; }
-	YY_BREAK
-case 41:
-YY_RULE_SETUP
-#line 143 "core/pbrtlex.ll"
-{ return VOLUME; }
-	YY_BREAK
-case 42:
-YY_RULE_SETUP
-#line 144 "core/pbrtlex.ll"
-{ return VOLUMEINTEGRATOR; }
-	YY_BREAK
-case 43:
-YY_RULE_SETUP
-#line 145 "core/pbrtlex.ll"
-{ return WORLDBEGIN; }
-	YY_BREAK
-case 44:
-YY_RULE_SETUP
-#line 146 "core/pbrtlex.ll"
-{ return WORLDEND; }
-	YY_BREAK
-case 45:
-YY_RULE_SETUP
-#line 147 "core/pbrtlex.ll"
-/* do nothing */
-	YY_BREAK
-case 46:
-/* rule 46 can match eol */
-YY_RULE_SETUP
-#line 148 "core/pbrtlex.ll"
-{ line_num++; }
-	YY_BREAK
-case 47:
-YY_RULE_SETUP
-#line 149 "core/pbrtlex.ll"
-{
-    yylval.num = (float) atof(yytext);
-    return NUM;
-}
-	YY_BREAK
-case 48:
-YY_RULE_SETUP
-#line 155 "core/pbrtlex.ll"
-{
-    strcpy(yylval.string, yytext);
-    return ID;
-}
-	YY_BREAK
-case 49:
-YY_RULE_SETUP
-#line 161 "core/pbrtlex.ll"
-{ return LBRACK; }
-	YY_BREAK
-case 50:
-YY_RULE_SETUP
-#line 162 "core/pbrtlex.ll"
-{ return RBRACK; }
-	YY_BREAK
-case 51:
-YY_RULE_SETUP
-#line 163 "core/pbrtlex.ll"
-{ BEGIN STR; str_pos = 0; }
-	YY_BREAK
-case 52:
-YY_RULE_SETUP
-#line 164 "core/pbrtlex.ll"
-{add_string_char('\n');}
-	YY_BREAK
-case 53:
-YY_RULE_SETUP
-#line 165 "core/pbrtlex.ll"
-{add_string_char('\t');}
-	YY_BREAK
-case 54:
-YY_RULE_SETUP
-#line 166 "core/pbrtlex.ll"
-{add_string_char('\r');}
-	YY_BREAK
-case 55:
-YY_RULE_SETUP
-#line 167 "core/pbrtlex.ll"
-{add_string_char('\b');}
-	YY_BREAK
-case 56:
-YY_RULE_SETUP
-#line 168 "core/pbrtlex.ll"
-{add_string_char('\f');}
-	YY_BREAK
-case 57:
-YY_RULE_SETUP
-#line 169 "core/pbrtlex.ll"
-{add_string_char('\"');}
-	YY_BREAK
-case 58:
-YY_RULE_SETUP
-#line 170 "core/pbrtlex.ll"
-{add_string_char('\\');}
-	YY_BREAK
-case 59:
-YY_RULE_SETUP
-#line 171 "core/pbrtlex.ll"
-{
-  int val = atoi(yytext+1);
-  while (val > 256)
-    val -= 256;
-  add_string_char(val);
-}
-	YY_BREAK
-case 60:
-/* rule 60 can match eol */
-YY_RULE_SETUP
-#line 179 "core/pbrtlex.ll"
-{line_num++;}
-	YY_BREAK
-case 61:
-YY_RULE_SETUP
-#line 180 "core/pbrtlex.ll"
-{ add_string_char(yytext[1]);}
-	YY_BREAK
-case 62:
-YY_RULE_SETUP
-#line 181 "core/pbrtlex.ll"
-{BEGIN INITIAL; return STRING;}
-	YY_BREAK
-case 63:
-YY_RULE_SETUP
-#line 182 "core/pbrtlex.ll"
-{add_string_char(yytext[0]);}
-	YY_BREAK
-case 64:
-/* rule 64 can match eol */
-YY_RULE_SETUP
-#line 183 "core/pbrtlex.ll"
-{Error("Unterminated string!");}
-	YY_BREAK
-case 65:
-YY_RULE_SETUP
-#line 185 "core/pbrtlex.ll"
-{ Error( "Illegal character: %c (0x%x)", yytext[0], int(yytext[0])); }
-	YY_BREAK
-case 66:
-YY_RULE_SETUP
-#line 186 "core/pbrtlex.ll"
-ECHO;
-	YY_BREAK
-#line 1396 "core/pbrtlex.cpp"
-case YY_STATE_EOF(INITIAL):
-case YY_STATE_EOF(STR):
-case YY_STATE_EOF(COMMENT):
-case YY_STATE_EOF(INCL):
-case YY_STATE_EOF(INCL_FILE):
-	yyterminate();
-
-	case YY_END_OF_BUFFER:
-		{
-		/* Amount of text matched not including the EOB char. */
-		int yy_amount_of_matched_text = (int) (yy_cp - (yytext_ptr)) - 1;
-
-		/* Undo the effects of YY_DO_BEFORE_ACTION. */
-		*yy_cp = (yy_hold_char);
-		YY_RESTORE_YY_MORE_OFFSET
-
-		if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_NEW )
-			{
-			/* We're scanning a new file or input source.  It's
-			 * possible that this happened because the user
-			 * just pointed yyin at a new source and called
-			 * yylex().  If so, then we have to assure
-			 * consistency between YY_CURRENT_BUFFER and our
-			 * globals.  Here is the right place to do so, because
-			 * this is the first action (other than possibly a
-			 * back-up) that will match for the new input source.
-			 */
-			(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-			YY_CURRENT_BUFFER_LVALUE->yy_input_file = yyin;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status = YY_BUFFER_NORMAL;
-			}
-
-		/* Note that here we test for yy_c_buf_p "<=" to the position
-		 * of the first EOB in the buffer, since yy_c_buf_p will
-		 * already have been incremented past the NUL character
-		 * (since all states make transitions on EOB to the
-		 * end-of-buffer state).  Contrast this with the test
-		 * in input().
-		 */
-		if ( (yy_c_buf_p) <= &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			{ /* This was really a NUL. */
-			yy_state_type yy_next_state;
-
-			(yy_c_buf_p) = (yytext_ptr) + yy_amount_of_matched_text;
-
-			yy_current_state = yy_get_previous_state(  );
-
-			/* Okay, we're now positioned to make the NUL
-			 * transition.  We couldn't have
-			 * yy_get_previous_state() go ahead and do it
-			 * for us because it doesn't know how to deal
-			 * with the possibility of jamming (and we don't
-			 * want to build jamming into it because then it
-			 * will run more slowly).
-			 */
-
-			yy_next_state = yy_try_NUL_trans( yy_current_state );
-
-			yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-
-			if ( yy_next_state )
-				{
-				/* Consume the NUL. */
-				yy_cp = ++(yy_c_buf_p);
-				yy_current_state = yy_next_state;
-				goto yy_match;
-				}
-
-			else
-				{
-				yy_cp = (yy_c_buf_p);
-				goto yy_find_action;
-				}
-			}
-
-		else switch ( yy_get_next_buffer(  ) )
-			{
-			case EOB_ACT_END_OF_FILE:
-				{
-				(yy_did_buffer_switch_on_eof) = 0;
-
-				if ( yywrap( ) )
-					{
-					/* Note: because we've taken care in
-					 * yy_get_next_buffer() to have set up
-					 * yytext, we can now set up
-					 * yy_c_buf_p so that if some total
-					 * hoser (like flex itself) wants to
-					 * call the scanner after we return the
-					 * YY_NULL, it'll still work - another
-					 * YY_NULL will get returned.
-					 */
-					(yy_c_buf_p) = (yytext_ptr) + YY_MORE_ADJ;
-
-					yy_act = YY_STATE_EOF(YY_START);
-					goto do_action;
-					}
-
-				else
-					{
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-					}
-				break;
-				}
-
-			case EOB_ACT_CONTINUE_SCAN:
-				(yy_c_buf_p) =
-					(yytext_ptr) + yy_amount_of_matched_text;
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_match;
-
-			case EOB_ACT_LAST_MATCH:
-				(yy_c_buf_p) =
-				&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)];
-
-				yy_current_state = yy_get_previous_state(  );
-
-				yy_cp = (yy_c_buf_p);
-				yy_bp = (yytext_ptr) + YY_MORE_ADJ;
-				goto yy_find_action;
-			}
-		break;
-		}
-
-	default:
-		YY_FATAL_ERROR(
-			"fatal flex scanner internal error--no action found" );
-	} /* end of action switch */
-		} /* end of scanning one token */
-} /* end of yylex */
-
-/* yy_get_next_buffer - try to read in a new buffer
- *
- * Returns a code representing an action:
- *	EOB_ACT_LAST_MATCH -
- *	EOB_ACT_CONTINUE_SCAN - continue scanning from current position
- *	EOB_ACT_END_OF_FILE - end of file
- */
-static int yy_get_next_buffer (void)
-{
-    	register char *dest = YY_CURRENT_BUFFER_LVALUE->yy_ch_buf;
-	register char *source = (yytext_ptr);
-	register int number_to_move, i;
-	int ret_val;
-
-	if ( (yy_c_buf_p) > &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] )
-		YY_FATAL_ERROR(
-		"fatal flex scanner internal error--end of buffer missed" );
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_fill_buffer == 0 )
-		{ /* Don't try to fill the buffer, so this is an EOF. */
-		if ( (yy_c_buf_p) - (yytext_ptr) - YY_MORE_ADJ == 1 )
-			{
-			/* We matched a single character, the EOB, so
-			 * treat this as a final EOF.
-			 */
-			return EOB_ACT_END_OF_FILE;
-			}
-
-		else
-			{
-			/* We matched some text prior to the EOB, first
-			 * process it.
-			 */
-			return EOB_ACT_LAST_MATCH;
-			}
-		}
-
-	/* Try to read more data. */
-
-	/* First move last chars to start of buffer. */
-	number_to_move = (int) ((yy_c_buf_p) - (yytext_ptr)) - 1;
-
-	for ( i = 0; i < number_to_move; ++i )
-		*(dest++) = *(source++);
-
-	if ( YY_CURRENT_BUFFER_LVALUE->yy_buffer_status == YY_BUFFER_EOF_PENDING )
-		/* don't do the read, it's not guaranteed to return an EOF,
-		 * just force an EOF
-		 */
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars) = 0;
-
-	else
-		{
-			yy_size_t num_to_read =
-			YY_CURRENT_BUFFER_LVALUE->yy_buf_size - number_to_move - 1;
-
-		while ( num_to_read <= 0 )
-			{ /* Not enough room in the buffer - grow it. */
-
-			/* just a shorter name for the current buffer */
-			YY_BUFFER_STATE b = YY_CURRENT_BUFFER;
-
-			int yy_c_buf_p_offset =
-				(int) ((yy_c_buf_p) - b->yy_ch_buf);
-
-			if ( b->yy_is_our_buffer )
-				{
-				yy_size_t new_size = b->yy_buf_size * 2;
-
-				if ( new_size <= 0 )
-					b->yy_buf_size += b->yy_buf_size / 8;
-				else
-					b->yy_buf_size *= 2;
-
-				b->yy_ch_buf = (char *)
-					/* Include room in for 2 EOB chars. */
-					yyrealloc((void *) b->yy_ch_buf,b->yy_buf_size + 2  );
-				}
-			else
-				/* Can't grow it, we don't own it. */
-				b->yy_ch_buf = 0;
-
-			if ( ! b->yy_ch_buf )
-				YY_FATAL_ERROR(
-				"fatal error - scanner input buffer overflow" );
-
-			(yy_c_buf_p) = &b->yy_ch_buf[yy_c_buf_p_offset];
-
-			num_to_read = YY_CURRENT_BUFFER_LVALUE->yy_buf_size -
-						number_to_move - 1;
-
-			}
-
-		if ( num_to_read > YY_READ_BUF_SIZE )
-			num_to_read = YY_READ_BUF_SIZE;
-
-		/* Read in more data. */
-		YY_INPUT( (&YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[number_to_move]),
-			(yy_n_chars), num_to_read );
-
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	if ( (yy_n_chars) == 0 )
-		{
-		if ( number_to_move == YY_MORE_ADJ )
-			{
-			ret_val = EOB_ACT_END_OF_FILE;
-			yyrestart(yyin  );
-			}
-
-		else
-			{
-			ret_val = EOB_ACT_LAST_MATCH;
-			YY_CURRENT_BUFFER_LVALUE->yy_buffer_status =
-				YY_BUFFER_EOF_PENDING;
-			}
-		}
-
-	else
-		ret_val = EOB_ACT_CONTINUE_SCAN;
-
-	if ((yy_size_t) ((yy_n_chars) + number_to_move) > YY_CURRENT_BUFFER_LVALUE->yy_buf_size) {
-		/* Extend the array by 50%, plus the number we really need. */
-		yy_size_t new_size = (yy_n_chars) + number_to_move + ((yy_n_chars) >> 1);
-		YY_CURRENT_BUFFER_LVALUE->yy_ch_buf = (char *) yyrealloc((void *) YY_CURRENT_BUFFER_LVALUE->yy_ch_buf,new_size  );
-		if ( ! YY_CURRENT_BUFFER_LVALUE->yy_ch_buf )
-			YY_FATAL_ERROR( "out of dynamic memory in yy_get_next_buffer()" );
-	}
-
-	(yy_n_chars) += number_to_move;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] = YY_END_OF_BUFFER_CHAR;
-	YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars) + 1] = YY_END_OF_BUFFER_CHAR;
-
-	(yytext_ptr) = &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[0];
-
-	return ret_val;
-}
-
-/* yy_get_previous_state - get the state just before the EOB char was reached */
-
-    static yy_state_type yy_get_previous_state (void)
-{
-	register yy_state_type yy_current_state;
-	register char *yy_cp;
-    
-	yy_current_state = (yy_start);
-
-	for ( yy_cp = (yytext_ptr) + YY_MORE_ADJ; yy_cp < (yy_c_buf_p); ++yy_cp )
-		{
-		register YY_CHAR yy_c = (*yy_cp ? yy_ec[YY_SC_TO_UI(*yy_cp)] : 1);
-		if ( yy_accept[yy_current_state] )
-			{
-			(yy_last_accepting_state) = yy_current_state;
-			(yy_last_accepting_cpos) = yy_cp;
-			}
-		while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-			{
-			yy_current_state = (int) yy_def[yy_current_state];
-			if ( yy_current_state >= 394 )
-				yy_c = yy_meta[(unsigned int) yy_c];
-			}
-		yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-		}
-
-	return yy_current_state;
-}
-
-/* yy_try_NUL_trans - try to make a transition on the NUL character
- *
- * synopsis
- *	next_state = yy_try_NUL_trans( current_state );
- */
-    static yy_state_type yy_try_NUL_trans  (yy_state_type yy_current_state )
-{
-	register int yy_is_jam;
-    	register char *yy_cp = (yy_c_buf_p);
-
-	register YY_CHAR yy_c = 1;
-	if ( yy_accept[yy_current_state] )
-		{
-		(yy_last_accepting_state) = yy_current_state;
-		(yy_last_accepting_cpos) = yy_cp;
-		}
-	while ( yy_chk[yy_base[yy_current_state] + yy_c] != yy_current_state )
-		{
-		yy_current_state = (int) yy_def[yy_current_state];
-		if ( yy_current_state >= 394 )
-			yy_c = yy_meta[(unsigned int) yy_c];
-		}
-	yy_current_state = yy_nxt[yy_base[yy_current_state] + (unsigned int) yy_c];
-	yy_is_jam = (yy_current_state == 393);
-
-	return yy_is_jam ? 0 : yy_current_state;
-}
-
-#ifndef YY_NO_INPUT
-#ifdef __cplusplus
-    static int yyinput (void)
-#else
-    static int input  (void)
-#endif
-
-{
-	int c;
-    
-	*(yy_c_buf_p) = (yy_hold_char);
-
-	if ( *(yy_c_buf_p) == YY_END_OF_BUFFER_CHAR )
-		{
-		/* yy_c_buf_p now points to the character we want to return.
-		 * If this occurs *before* the EOB characters, then it's a
-		 * valid NUL; if not, then we've hit the end of the buffer.
-		 */
-		if ( (yy_c_buf_p) < &YY_CURRENT_BUFFER_LVALUE->yy_ch_buf[(yy_n_chars)] )
-			/* This was really a NUL. */
-			*(yy_c_buf_p) = '\0';
-
-		else
-			{ /* need more input */
-			yy_size_t offset = (yy_c_buf_p) - (yytext_ptr);
-			++(yy_c_buf_p);
-
-			switch ( yy_get_next_buffer(  ) )
-				{
-				case EOB_ACT_LAST_MATCH:
-					/* This happens because yy_g_n_b()
-					 * sees that we've accumulated a
-					 * token and flags that we need to
-					 * try matching the token before
-					 * proceeding.  But for input(),
-					 * there's no matching to consider.
-					 * So convert the EOB_ACT_LAST_MATCH
-					 * to EOB_ACT_END_OF_FILE.
-					 */
-
-					/* Reset buffer status. */
-					yyrestart(yyin );
-
-					/*FALLTHROUGH*/
-
-				case EOB_ACT_END_OF_FILE:
-					{
-					if ( yywrap( ) )
-						return 0;
-
-					if ( ! (yy_did_buffer_switch_on_eof) )
-						YY_NEW_FILE;
-#ifdef __cplusplus
-					return yyinput();
-#else
-					return input();
-#endif
-					}
-
-				case EOB_ACT_CONTINUE_SCAN:
-					(yy_c_buf_p) = (yytext_ptr) + offset;
-					break;
-				}
-			}
-		}
-
-	c = *(unsigned char *) (yy_c_buf_p);	/* cast for 8-bit char's */
-	*(yy_c_buf_p) = '\0';	/* preserve yytext */
-	(yy_hold_char) = *++(yy_c_buf_p);
-
-	return c;
-}
-#endif	/* ifndef YY_NO_INPUT */
-
-/** Immediately switch to a different input stream.
- * @param input_file A readable stream.
- * 
- * @note This function does not reset the start condition to @c INITIAL .
- */
-    void yyrestart  (FILE * input_file )
-{
-    
-	if ( ! YY_CURRENT_BUFFER ){
-        yyensure_buffer_stack ();
-		YY_CURRENT_BUFFER_LVALUE =
-            yy_create_buffer(yyin,YY_BUF_SIZE );
-	}
-
-	yy_init_buffer(YY_CURRENT_BUFFER,input_file );
-	yy_load_buffer_state( );
-}
-
-/** Switch to a different input buffer.
- * @param new_buffer The new input buffer.
- * 
- */
-    void yy_switch_to_buffer  (YY_BUFFER_STATE  new_buffer )
-{
-    
-	/* TODO. We should be able to replace this entire function body
-	 * with
-	 *		yypop_buffer_state();
-	 *		yypush_buffer_state(new_buffer);
-     */
-	yyensure_buffer_stack ();
-	if ( YY_CURRENT_BUFFER == new_buffer )
-		return;
-
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-	yy_load_buffer_state( );
-
-	/* We don't actually know whether we did this switch during
-	 * EOF (yywrap()) processing, but the only time this flag
-	 * is looked at is after yywrap() is called, so it's safe
-	 * to go ahead and always set it.
-	 */
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-static void yy_load_buffer_state  (void)
-{
-    	(yy_n_chars) = YY_CURRENT_BUFFER_LVALUE->yy_n_chars;
-	(yytext_ptr) = (yy_c_buf_p) = YY_CURRENT_BUFFER_LVALUE->yy_buf_pos;
-	yyin = YY_CURRENT_BUFFER_LVALUE->yy_input_file;
-	(yy_hold_char) = *(yy_c_buf_p);
-}
-
-/** Allocate and initialize an input buffer state.
- * @param file A readable stream.
- * @param size The character buffer size in bytes. When in doubt, use @c YY_BUF_SIZE.
- * 
- * @return the allocated buffer state.
- */
-    YY_BUFFER_STATE yy_create_buffer  (FILE * file, int  size )
-{
-	YY_BUFFER_STATE b;
-    
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_buf_size = size;
-
-	/* yy_ch_buf has to be 2 characters longer than the size given because
-	 * we need to put in 2 end-of-buffer characters.
-	 */
-	b->yy_ch_buf = (char *) yyalloc(b->yy_buf_size + 2  );
-	if ( ! b->yy_ch_buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_create_buffer()" );
-
-	b->yy_is_our_buffer = 1;
-
-	yy_init_buffer(b,file );
-
-	return b;
-}
-
-/** Destroy the buffer.
- * @param b a buffer created with yy_create_buffer()
- * 
- */
-    void yy_delete_buffer (YY_BUFFER_STATE  b )
-{
-    
-	if ( ! b )
-		return;
-
-	if ( b == YY_CURRENT_BUFFER ) /* Not sure if we should pop here. */
-		YY_CURRENT_BUFFER_LVALUE = (YY_BUFFER_STATE) 0;
-
-	if ( b->yy_is_our_buffer )
-		yyfree((void *) b->yy_ch_buf  );
-
-	yyfree((void *) b  );
-}
-
-#ifndef __cplusplus
-extern int isatty (int );
-#endif /* __cplusplus */
-    
-/* Initializes or reinitializes a buffer.
- * This function is sometimes called more than once on the same buffer,
- * such as during a yyrestart() or at EOF.
- */
-    static void yy_init_buffer  (YY_BUFFER_STATE  b, FILE * file )
-
-{
-	int oerrno = errno;
-    
-	yy_flush_buffer(b );
-
-	b->yy_input_file = file;
-	b->yy_fill_buffer = 1;
-
-    /* If b is the current buffer, then yy_init_buffer was _probably_
-     * called from yyrestart() or through yy_get_next_buffer.
-     * In that case, we don't want to reset the lineno or column.
-     */
-    if (b != YY_CURRENT_BUFFER){
-        b->yy_bs_lineno = 1;
-        b->yy_bs_column = 0;
-    }
-
-        b->yy_is_interactive = file ? (isatty( fileno(file) ) > 0) : 0;
-    
-	errno = oerrno;
-}
-
-/** Discard all buffered characters. On the next scan, YY_INPUT will be called.
- * @param b the buffer state to be flushed, usually @c YY_CURRENT_BUFFER.
- * 
- */
-    void yy_flush_buffer (YY_BUFFER_STATE  b )
-{
-    	if ( ! b )
-		return;
-
-	b->yy_n_chars = 0;
-
-	/* We always need two end-of-buffer characters.  The first causes
-	 * a transition to the end-of-buffer state.  The second causes
-	 * a jam in that state.
-	 */
-	b->yy_ch_buf[0] = YY_END_OF_BUFFER_CHAR;
-	b->yy_ch_buf[1] = YY_END_OF_BUFFER_CHAR;
-
-	b->yy_buf_pos = &b->yy_ch_buf[0];
-
-	b->yy_at_bol = 1;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	if ( b == YY_CURRENT_BUFFER )
-		yy_load_buffer_state( );
-}
-
-/** Pushes the new state onto the stack. The new state becomes
- *  the current state. This function will allocate the stack
- *  if necessary.
- *  @param new_buffer The new state.
- *  
- */
-void yypush_buffer_state (YY_BUFFER_STATE new_buffer )
-{
-    	if (new_buffer == NULL)
-		return;
-
-	yyensure_buffer_stack();
-
-	/* This block is copied from yy_switch_to_buffer. */
-	if ( YY_CURRENT_BUFFER )
-		{
-		/* Flush out information for old buffer. */
-		*(yy_c_buf_p) = (yy_hold_char);
-		YY_CURRENT_BUFFER_LVALUE->yy_buf_pos = (yy_c_buf_p);
-		YY_CURRENT_BUFFER_LVALUE->yy_n_chars = (yy_n_chars);
-		}
-
-	/* Only push if top exists. Otherwise, replace top. */
-	if (YY_CURRENT_BUFFER)
-		(yy_buffer_stack_top)++;
-	YY_CURRENT_BUFFER_LVALUE = new_buffer;
-
-	/* copied from yy_switch_to_buffer. */
-	yy_load_buffer_state( );
-	(yy_did_buffer_switch_on_eof) = 1;
-}
-
-/** Removes and deletes the top of the stack, if present.
- *  The next element becomes the new top.
- *  
- */
-void yypop_buffer_state (void)
-{
-    	if (!YY_CURRENT_BUFFER)
-		return;
-
-	yy_delete_buffer(YY_CURRENT_BUFFER );
-	YY_CURRENT_BUFFER_LVALUE = NULL;
-	if ((yy_buffer_stack_top) > 0)
-		--(yy_buffer_stack_top);
-
-	if (YY_CURRENT_BUFFER) {
-		yy_load_buffer_state( );
-		(yy_did_buffer_switch_on_eof) = 1;
-	}
-}
-
-/* Allocates the stack if it does not exist.
- *  Guarantees space for at least one push.
- */
-static void yyensure_buffer_stack (void)
-{
-	yy_size_t num_to_alloc;
-    
-	if (!(yy_buffer_stack)) {
-
-		/* First allocation is just for 2 elements, since we don't know if this
-		 * scanner will even need a stack. We use 2 instead of 1 to avoid an
-		 * immediate realloc on the next call.
-         */
-		num_to_alloc = 1;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyalloc
-								(num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-								  
-		memset((yy_buffer_stack), 0, num_to_alloc * sizeof(struct yy_buffer_state*));
-				
-		(yy_buffer_stack_max) = num_to_alloc;
-		(yy_buffer_stack_top) = 0;
-		return;
-	}
-
-	if ((yy_buffer_stack_top) >= ((yy_buffer_stack_max)) - 1){
-
-		/* Increase the buffer to prepare for a possible push. */
-		int grow_size = 8 /* arbitrary grow size */;
-
-		num_to_alloc = (yy_buffer_stack_max) + grow_size;
-		(yy_buffer_stack) = (struct yy_buffer_state**)yyrealloc
-								((yy_buffer_stack),
-								num_to_alloc * sizeof(struct yy_buffer_state*)
-								);
-		if ( ! (yy_buffer_stack) )
-			YY_FATAL_ERROR( "out of dynamic memory in yyensure_buffer_stack()" );
-
-		/* zero only the new slots.*/
-		memset((yy_buffer_stack) + (yy_buffer_stack_max), 0, grow_size * sizeof(struct yy_buffer_state*));
-		(yy_buffer_stack_max) = num_to_alloc;
-	}
-}
-
-/** Setup the input buffer state to scan directly from a user-specified character buffer.
- * @param base the character buffer
- * @param size the size in bytes of the character buffer
- * 
- * @return the newly allocated buffer state object. 
- */
-YY_BUFFER_STATE yy_scan_buffer  (char * base, yy_size_t  size )
-{
-	YY_BUFFER_STATE b;
-    
-	if ( size < 2 ||
-	     base[size-2] != YY_END_OF_BUFFER_CHAR ||
-	     base[size-1] != YY_END_OF_BUFFER_CHAR )
-		/* They forgot to leave room for the EOB's. */
-		return 0;
-
-	b = (YY_BUFFER_STATE) yyalloc(sizeof( struct yy_buffer_state )  );
-	if ( ! b )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_buffer()" );
-
-	b->yy_buf_size = size - 2;	/* "- 2" to take care of EOB's */
-	b->yy_buf_pos = b->yy_ch_buf = base;
-	b->yy_is_our_buffer = 0;
-	b->yy_input_file = 0;
-	b->yy_n_chars = b->yy_buf_size;
-	b->yy_is_interactive = 0;
-	b->yy_at_bol = 1;
-	b->yy_fill_buffer = 0;
-	b->yy_buffer_status = YY_BUFFER_NEW;
-
-	yy_switch_to_buffer(b  );
-
-	return b;
-}
-
-/** Setup the input buffer state to scan a string. The next call to yylex() will
- * scan from a @e copy of @a str.
- * @param yystr a NUL-terminated string to scan
- * 
- * @return the newly allocated buffer state object.
- * @note If you want to scan bytes that may contain NUL values, then use
- *       yy_scan_bytes() instead.
- */
-YY_BUFFER_STATE yy_scan_string (yyconst char * yystr )
-{
-    
-	return yy_scan_bytes(yystr,strlen(yystr) );
-}
-
-/** Setup the input buffer state to scan the given bytes. The next call to yylex() will
- * scan from a @e copy of @a bytes.
- * @param bytes the byte buffer to scan
- * @param len the number of bytes in the buffer pointed to by @a bytes.
- * 
- * @return the newly allocated buffer state object.
- */
-YY_BUFFER_STATE yy_scan_bytes  (yyconst char * yybytes, yy_size_t  _yybytes_len )
-{
-	YY_BUFFER_STATE b;
-	char *buf;
-	yy_size_t n, i;
-    
-	/* Get memory for full buffer, including space for trailing EOB's. */
-	n = _yybytes_len + 2;
-	buf = (char *) yyalloc(n  );
-	if ( ! buf )
-		YY_FATAL_ERROR( "out of dynamic memory in yy_scan_bytes()" );
-
-	for ( i = 0; i < _yybytes_len; ++i )
-		buf[i] = yybytes[i];
-
-	buf[_yybytes_len] = buf[_yybytes_len+1] = YY_END_OF_BUFFER_CHAR;
-
-	b = yy_scan_buffer(buf,n );
-	if ( ! b )
-		YY_FATAL_ERROR( "bad buffer in yy_scan_bytes()" );
-
-	/* It's okay to grow etc. this buffer, and we should throw it
-	 * away when we're done.
-	 */
-	b->yy_is_our_buffer = 1;
-
-	return b;
-}
-
-#ifndef YY_EXIT_FAILURE
-#define YY_EXIT_FAILURE 2
-#endif
-
-static void yy_fatal_error (yyconst char* msg )
-{
-    	(void) fprintf( stderr, "%s\n", msg );
-	exit( YY_EXIT_FAILURE );
-}
-
-/* Redefine yyless() so it works in section 3 code. */
-
-#undef yyless
-#define yyless(n) \
-	do \
-		{ \
-		/* Undo effects of setting up yytext. */ \
-        int yyless_macro_arg = (n); \
-        YY_LESS_LINENO(yyless_macro_arg);\
-		yytext[yyleng] = (yy_hold_char); \
-		(yy_c_buf_p) = yytext + yyless_macro_arg; \
-		(yy_hold_char) = *(yy_c_buf_p); \
-		*(yy_c_buf_p) = '\0'; \
-		yyleng = yyless_macro_arg; \
-		} \
-	while ( 0 )
-
-/* Accessor  methods (get/set functions) to struct members. */
-
-/** Get the current line number.
- * 
- */
-int yyget_lineno  (void)
-{
-        
-    return yylineno;
-}
-
-/** Get the input stream.
- * 
- */
-FILE *yyget_in  (void)
-{
-        return yyin;
-}
-
-/** Get the output stream.
- * 
- */
-FILE *yyget_out  (void)
-{
-        return yyout;
-}
-
-/** Get the length of the current token.
- * 
- */
-yy_size_t yyget_leng  (void)
-{
-        return yyleng;
-}
-
-/** Get the current token.
- * 
- */
-
-char *yyget_text  (void)
-{
-        return yytext;
-}
-
-/** Set the current line number.
- * @param line_number
- * 
- */
-void yyset_lineno (int  line_number )
-{
-    
-    yylineno = line_number;
-}
-
-/** Set the input stream. This does not discard the current
- * input buffer.
- * @param in_str A readable stream.
- * 
- * @see yy_switch_to_buffer
- */
-void yyset_in (FILE *  in_str )
-{
-        yyin = in_str ;
-}
-
-void yyset_out (FILE *  out_str )
-{
-        yyout = out_str ;
-}
-
-int yyget_debug  (void)
-{
-        return yy_flex_debug;
-}
-
-void yyset_debug (int  bdebug )
-{
-        yy_flex_debug = bdebug ;
-}
-
-static int yy_init_globals (void)
-{
-        /* Initialization is the same as for the non-reentrant scanner.
-     * This function is called from yylex_destroy(), so don't allocate here.
-     */
-
-    (yy_buffer_stack) = 0;
-    (yy_buffer_stack_top) = 0;
-    (yy_buffer_stack_max) = 0;
-    (yy_c_buf_p) = (char *) 0;
-    (yy_init) = 0;
-    (yy_start) = 0;
-
-/* Defined in main.c */
-#ifdef YY_STDINIT
-    yyin = stdin;
-    yyout = stdout;
-#else
-    yyin = (FILE *) 0;
-    yyout = (FILE *) 0;
-#endif
-
-    /* For future reference: Set errno on error, since we are called by
-     * yylex_init()
-     */
-    return 0;
-}
-
-/* yylex_destroy is for both reentrant and non-reentrant scanners. */
-int yylex_destroy  (void)
-{
-    
-    /* Pop the buffer stack, destroying each element. */
-	while(YY_CURRENT_BUFFER){
-		yy_delete_buffer(YY_CURRENT_BUFFER  );
-		YY_CURRENT_BUFFER_LVALUE = NULL;
-		yypop_buffer_state();
-	}
-
-	/* Destroy the stack itself. */
-	yyfree((yy_buffer_stack) );
-	(yy_buffer_stack) = NULL;
-
-    /* Reset the globals. This is important in a non-reentrant scanner so the next time
-     * yylex() is called, initialization will occur. */
-    yy_init_globals( );
-
-    return 0;
-}
-
-/*
- * Internal utility routines.
- */
-
-#ifndef yytext_ptr
-static void yy_flex_strncpy (char* s1, yyconst char * s2, int n )
-{
-	register int i;
-	for ( i = 0; i < n; ++i )
-		s1[i] = s2[i];
-}
-#endif
-
-#ifdef YY_NEED_STRLEN
-static int yy_flex_strlen (yyconst char * s )
-{
-	register int n;
-	for ( n = 0; s[n]; ++n )
-		;
-
-	return n;
-}
-#endif
-
-void *yyalloc (yy_size_t  size )
-{
-	return (void *) malloc( size );
-}
-
-void *yyrealloc  (void * ptr, yy_size_t  size )
-{
-	/* The cast to (char *) in the following accommodates both
-	 * implementations that use char* generic pointers, and those
-	 * that use void* generic pointers.  It works with the latter
-	 * because both ANSI C and C++ allow castless assignment from
-	 * any pointer type to void*, and deal with argument conversions
-	 * as though doing an assignment.
-	 */
-	return (void *) realloc( (char *) ptr, size );
-}
-
-void yyfree (void * ptr )
-{
-	free( (char *) ptr );	/* see yyrealloc() for (char *) cast */
-}
-
-#define YYTABLES_NAME "yytables"
-
-#line 186 "core/pbrtlex.ll"
-
-
-int yywrap() {
-    if (includeStack.size() == 0) return 1;
-    include_pop();
-    return 0;
-}
-
-
-
-
diff -uarN pbrt/core/pbrtparse.cpp rendernet_pbrt/core/pbrtparse.cpp
--- pbrt/core/pbrtparse.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/pbrtparse.cpp	1970-01-01 00:00:00.000000000 +0000
@@ -1,2683 +0,0 @@
-/* A Bison parser, made by GNU Bison 2.5.  */
-
-/* Bison implementation for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2011 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-   
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
-
-/* C LALR(1) parser skeleton written by Richard Stallman, by
-   simplifying the original so-called "semantic" parser.  */
-
-/* All symbols defined below should begin with yy or YY, to avoid
-   infringing on user name space.  This should be done even for local
-   variables, as they might otherwise be expanded by user macros.
-   There are some unavoidable exceptions within include files to
-   define necessary library symbols; they are noted "INFRINGES ON
-   USER NAME SPACE" below.  */
-
-/* Identify Bison output.  */
-#define YYBISON 1
-
-/* Bison version.  */
-#define YYBISON_VERSION "2.5"
-
-/* Skeleton name.  */
-#define YYSKELETON_NAME "yacc.c"
-
-/* Pure parsers.  */
-#define YYPURE 0
-
-/* Push parsers.  */
-#define YYPUSH 0
-
-/* Pull parsers.  */
-#define YYPULL 1
-
-/* Using locations.  */
-#define YYLSP_NEEDED 0
-
-
-
-/* Copy the first part of user declarations.  */
-
-/* Line 268 of yacc.c  */
-#line 24 "core/pbrtparse.yy"
-
-#include "api.h"
-#include "pbrt.h"
-#include "paramset.h"
-#include <stdarg.h>
-
-#ifdef PBRT_IS_WINDOWS
-#pragma warning(disable:4065)
-#pragma warning(disable:4996)
-#pragma warning(disable:4018)
-#endif // PBRT_IS_WINDOWS
-
-extern int yylex();
-extern void include_push(char *filename);
-int line_num = 0;
-string current_file;
-
-#define YYMAXDEPTH 100000000
-
-void yyerror(const char *str) {
-    Severe("Parsing error: %s", str);
-}
-
-
-
-struct ParamArray {
-    ParamArray() {
-        isString = false;
-        element_size = allocated = nelems = 0;
-        array = NULL;
-    }
-    bool isString;
-    int element_size;
-    int allocated;
-    int nelems;
-    void *array;
-};
-
-
-
-struct ParamListItem {
-    ParamListItem(const char *t, ParamArray *array) {
-        arg = array->array;
-        name = t;
-        size = array->nelems;
-        isString = array->isString;
-        array->allocated = 0;
-        array->nelems = 0;
-        array->array = NULL;
-    }
-    const char *name;
-    void *arg;
-    int size;
-    bool isString;
-};
-
-
-
-static vector<ParamListItem> cur_paramlist;
-
-static ParamArray *cur_array = NULL;
-
-static void AddArrayElement(void *elem) {
-    if (cur_array->nelems >= cur_array->allocated) {
-        cur_array->allocated = 2*cur_array->allocated + 1;
-        cur_array->array = realloc(cur_array->array,
-            cur_array->allocated*cur_array->element_size);
-    }
-    char *next = ((char *)cur_array->array) + cur_array->nelems * cur_array->element_size;
-    Assert(cur_array->element_size == 4 || cur_array->element_size == 8);
-    if (cur_array->element_size == 4)
-        *((uint32_t *)next) = *((uint32_t *)elem);
-    else
-        *((uint64_t *)next) = *((uint64_t *)elem);
-    cur_array->nelems++;
-}
-
-
-
-static void ArrayFree(ParamArray *ra) {
-    if (ra->isString && ra->array)
-        for (int i = 0; i < ra->nelems; ++i) free(((char **)ra->array)[i]);
-    free(ra->array);
-    delete ra;
-}
-
-
-
-static void FreeArgs() {
-    for (uint32_t i = 0; i < cur_paramlist.size(); ++i)
-        free((char *)cur_paramlist[i].arg);
-    cur_paramlist.erase(cur_paramlist.begin(), cur_paramlist.end());
-}
-
-
-
-static bool VerifyArrayLength(ParamArray *arr, int required,
-    const char *command) {
-    if (arr->nelems != required) {
-        Error("\"%s\" requires a %d element array! (%d found)",
-                    command, required, arr->nelems);
-        return false;
-    }
-    return true;
-}
-
-
-enum { PARAM_TYPE_INT, PARAM_TYPE_BOOL, PARAM_TYPE_FLOAT, PARAM_TYPE_POINT,
-    PARAM_TYPE_VECTOR, PARAM_TYPE_NORMAL, PARAM_TYPE_RGB, PARAM_TYPE_XYZ,
-    PARAM_TYPE_BLACKBODY, PARAM_TYPE_SPECTRUM,
-    PARAM_TYPE_STRING, PARAM_TYPE_TEXTURE };
-static const char *paramTypeToName(int type);
-static void InitParamSet(ParamSet &ps, SpectrumType);
-static bool lookupType(const char *name, int *type, string &sname);
-#define YYPRINT(file, type, value)  { \
-    if ((type) == ID || (type) == STRING) \
-        fprintf ((file), " %s", (value).string); \
-    else if ((type) == NUM) \
-        fprintf ((file), " %f", (value).num); \
-}
-
-
-
-
-/* Line 268 of yacc.c  */
-#line 196 "core/pbrtparse.cpp"
-
-/* Enabling traces.  */
-#ifndef YYDEBUG
-# define YYDEBUG 1
-#endif
-
-/* Enabling verbose error messages.  */
-#ifdef YYERROR_VERBOSE
-# undef YYERROR_VERBOSE
-# define YYERROR_VERBOSE 1
-#else
-# define YYERROR_VERBOSE 0
-#endif
-
-/* Enabling the token table.  */
-#ifndef YYTOKEN_TABLE
-# define YYTOKEN_TABLE 0
-#endif
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     STRING = 258,
-     ID = 259,
-     NUM = 260,
-     LBRACK = 261,
-     RBRACK = 262,
-     ACCELERATOR = 263,
-     ACTIVETRANSFORM = 264,
-     ALL = 265,
-     AREALIGHTSOURCE = 266,
-     ATTRIBUTEBEGIN = 267,
-     ATTRIBUTEEND = 268,
-     CAMERA = 269,
-     CONCATTRANSFORM = 270,
-     COORDINATESYSTEM = 271,
-     COORDSYSTRANSFORM = 272,
-     ENDTIME = 273,
-     FILM = 274,
-     IDENTITY = 275,
-     INCLUDE = 276,
-     LIGHTSOURCE = 277,
-     LOOKAT = 278,
-     MAKENAMEDMATERIAL = 279,
-     MATERIAL = 280,
-     NAMEDMATERIAL = 281,
-     OBJECTBEGIN = 282,
-     OBJECTEND = 283,
-     OBJECTINSTANCE = 284,
-     PIXELFILTER = 285,
-     RENDERER = 286,
-     REVERSEORIENTATION = 287,
-     ROTATE = 288,
-     SAMPLER = 289,
-     SCALE = 290,
-     SHAPE = 291,
-     STARTTIME = 292,
-     SURFACEINTEGRATOR = 293,
-     TEXTURE = 294,
-     TRANSFORMBEGIN = 295,
-     TRANSFORMEND = 296,
-     TRANSFORMTIMES = 297,
-     TRANSFORM = 298,
-     TRANSLATE = 299,
-     VOLUME = 300,
-     VOLUMEINTEGRATOR = 301,
-     WORLDBEGIN = 302,
-     WORLDEND = 303,
-     HIGH_PRECEDENCE = 304
-   };
-#endif
-
-
-
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE
-{
-
-/* Line 301 of yacc.c  */
-#line 148 "core/pbrtparse.yy"
-
-char string[1024];
-float num;
-ParamArray *ribarray;
-
-
-
-/* Line 301 of yacc.c  */
-#line 289 "core/pbrtparse.cpp"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-
-/* Copy the second part of user declarations.  */
-
-
-/* Line 343 of yacc.c  */
-#line 301 "core/pbrtparse.cpp"
-
-#ifdef short
-# undef short
-#endif
-
-#ifdef YYTYPE_UINT8
-typedef YYTYPE_UINT8 yytype_uint8;
-#else
-typedef unsigned char yytype_uint8;
-#endif
-
-#ifdef YYTYPE_INT8
-typedef YYTYPE_INT8 yytype_int8;
-#elif (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-typedef signed char yytype_int8;
-#else
-typedef short int yytype_int8;
-#endif
-
-#ifdef YYTYPE_UINT16
-typedef YYTYPE_UINT16 yytype_uint16;
-#else
-typedef unsigned short int yytype_uint16;
-#endif
-
-#ifdef YYTYPE_INT16
-typedef YYTYPE_INT16 yytype_int16;
-#else
-typedef short int yytype_int16;
-#endif
-
-#ifndef YYSIZE_T
-# ifdef __SIZE_TYPE__
-#  define YYSIZE_T __SIZE_TYPE__
-# elif defined size_t
-#  define YYSIZE_T size_t
-# elif ! defined YYSIZE_T && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-#  include <stddef.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYSIZE_T size_t
-# else
-#  define YYSIZE_T unsigned int
-# endif
-#endif
-
-#define YYSIZE_MAXIMUM ((YYSIZE_T) -1)
-
-#ifndef YY_
-# if defined YYENABLE_NLS && YYENABLE_NLS
-#  if ENABLE_NLS
-#   include <libintl.h> /* INFRINGES ON USER NAME SPACE */
-#   define YY_(msgid) dgettext ("bison-runtime", msgid)
-#  endif
-# endif
-# ifndef YY_
-#  define YY_(msgid) msgid
-# endif
-#endif
-
-/* Suppress unused-variable warnings by "using" E.  */
-#if ! defined lint || defined __GNUC__
-# define YYUSE(e) ((void) (e))
-#else
-# define YYUSE(e) /* empty */
-#endif
-
-/* Identity function, used to suppress warnings about constant conditions.  */
-#ifndef lint
-# define YYID(n) (n)
-#else
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static int
-YYID (int yyi)
-#else
-static int
-YYID (yyi)
-    int yyi;
-#endif
-{
-  return yyi;
-}
-#endif
-
-#if ! defined yyoverflow || YYERROR_VERBOSE
-
-/* The parser invokes alloca or malloc; define the necessary symbols.  */
-
-# ifdef YYSTACK_USE_ALLOCA
-#  if YYSTACK_USE_ALLOCA
-#   ifdef __GNUC__
-#    define YYSTACK_ALLOC __builtin_alloca
-#   elif defined __BUILTIN_VA_ARG_INCR
-#    include <alloca.h> /* INFRINGES ON USER NAME SPACE */
-#   elif defined _AIX
-#    define YYSTACK_ALLOC __alloca
-#   elif defined _MSC_VER
-#    include <malloc.h> /* INFRINGES ON USER NAME SPACE */
-#    define alloca _alloca
-#   else
-#    define YYSTACK_ALLOC alloca
-#    if ! defined _ALLOCA_H && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-#     include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#     ifndef EXIT_SUCCESS
-#      define EXIT_SUCCESS 0
-#     endif
-#    endif
-#   endif
-#  endif
-# endif
-
-# ifdef YYSTACK_ALLOC
-   /* Pacify GCC's `empty if-body' warning.  */
-#  define YYSTACK_FREE(Ptr) do { /* empty */; } while (YYID (0))
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-    /* The OS might guarantee only one guard page at the bottom of the stack,
-       and a page size can be as small as 4096 bytes.  So we cannot safely
-       invoke alloca (N) if N exceeds 4096.  Use a slightly smaller number
-       to allow for a few compiler-allocated temporary stack slots.  */
-#   define YYSTACK_ALLOC_MAXIMUM 4032 /* reasonable circa 2006 */
-#  endif
-# else
-#  define YYSTACK_ALLOC YYMALLOC
-#  define YYSTACK_FREE YYFREE
-#  ifndef YYSTACK_ALLOC_MAXIMUM
-#   define YYSTACK_ALLOC_MAXIMUM YYSIZE_MAXIMUM
-#  endif
-#  if (defined __cplusplus && ! defined EXIT_SUCCESS \
-       && ! ((defined YYMALLOC || defined malloc) \
-	     && (defined YYFREE || defined free)))
-#   include <stdlib.h> /* INFRINGES ON USER NAME SPACE */
-#   ifndef EXIT_SUCCESS
-#    define EXIT_SUCCESS 0
-#   endif
-#  endif
-#  ifndef YYMALLOC
-#   define YYMALLOC malloc
-#   if ! defined malloc && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-void *malloc (YYSIZE_T); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-#  ifndef YYFREE
-#   define YYFREE free
-#   if ! defined free && ! defined EXIT_SUCCESS && (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-void free (void *); /* INFRINGES ON USER NAME SPACE */
-#   endif
-#  endif
-# endif
-#endif /* ! defined yyoverflow || YYERROR_VERBOSE */
-
-
-#if (! defined yyoverflow \
-     && (! defined __cplusplus \
-	 || (defined YYSTYPE_IS_TRIVIAL && YYSTYPE_IS_TRIVIAL)))
-
-/* A type that is properly aligned for any stack member.  */
-union yyalloc
-{
-  yytype_int16 yyss_alloc;
-  YYSTYPE yyvs_alloc;
-};
-
-/* The size of the maximum gap between one aligned stack and the next.  */
-# define YYSTACK_GAP_MAXIMUM (sizeof (union yyalloc) - 1)
-
-/* The size of an array large to enough to hold all stacks, each with
-   N elements.  */
-# define YYSTACK_BYTES(N) \
-     ((N) * (sizeof (yytype_int16) + sizeof (YYSTYPE)) \
-      + YYSTACK_GAP_MAXIMUM)
-
-# define YYCOPY_NEEDED 1
-
-/* Relocate STACK from its old location to the new one.  The
-   local variables YYSIZE and YYSTACKSIZE give the old and new number of
-   elements in the stack, and YYPTR gives the new location of the
-   stack.  Advance YYPTR to a properly aligned location for the next
-   stack.  */
-# define YYSTACK_RELOCATE(Stack_alloc, Stack)				\
-    do									\
-      {									\
-	YYSIZE_T yynewbytes;						\
-	YYCOPY (&yyptr->Stack_alloc, Stack, yysize);			\
-	Stack = &yyptr->Stack_alloc;					\
-	yynewbytes = yystacksize * sizeof (*Stack) + YYSTACK_GAP_MAXIMUM; \
-	yyptr += yynewbytes / sizeof (*yyptr);				\
-      }									\
-    while (YYID (0))
-
-#endif
-
-#if defined YYCOPY_NEEDED && YYCOPY_NEEDED
-/* Copy COUNT objects from FROM to TO.  The source and destination do
-   not overlap.  */
-# ifndef YYCOPY
-#  if defined __GNUC__ && 1 < __GNUC__
-#   define YYCOPY(To, From, Count) \
-      __builtin_memcpy (To, From, (Count) * sizeof (*(From)))
-#  else
-#   define YYCOPY(To, From, Count)		\
-      do					\
-	{					\
-	  YYSIZE_T yyi;				\
-	  for (yyi = 0; yyi < (Count); yyi++)	\
-	    (To)[yyi] = (From)[yyi];		\
-	}					\
-      while (YYID (0))
-#  endif
-# endif
-#endif /* !YYCOPY_NEEDED */
-
-/* YYFINAL -- State number of the termination state.  */
-#define YYFINAL  75
-/* YYLAST -- Last index in YYTABLE.  */
-#define YYLAST   118
-
-/* YYNTOKENS -- Number of terminals.  */
-#define YYNTOKENS  50
-/* YYNNTS -- Number of nonterminals.  */
-#define YYNNTS  20
-/* YYNRULES -- Number of rules.  */
-#define YYNRULES  66
-/* YYNRULES -- Number of states.  */
-#define YYNSTATES  136
-
-/* YYTRANSLATE(YYLEX) -- Bison symbol number corresponding to YYLEX.  */
-#define YYUNDEFTOK  2
-#define YYMAXUTOK   304
-
-#define YYTRANSLATE(YYX)						\
-  ((unsigned int) (YYX) <= YYMAXUTOK ? yytranslate[YYX] : YYUNDEFTOK)
-
-/* YYTRANSLATE[YYLEX] -- Bison symbol number corresponding to YYLEX.  */
-static const yytype_uint8 yytranslate[] =
-{
-       0,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     2,     2,     2,     2,
-       2,     2,     2,     2,     2,     2,     1,     2,     3,     4,
-       5,     6,     7,     8,     9,    10,    11,    12,    13,    14,
-      15,    16,    17,    18,    19,    20,    21,    22,    23,    24,
-      25,    26,    27,    28,    29,    30,    31,    32,    33,    34,
-      35,    36,    37,    38,    39,    40,    41,    42,    43,    44,
-      45,    46,    47,    48,    49
-};
-
-#if YYDEBUG
-/* YYPRHS[YYN] -- Index of the first RHS symbol of rule number YYN in
-   YYRHS.  */
-static const yytype_uint8 yyprhs[] =
-{
-       0,     0,     3,     5,     6,     7,     8,    10,    12,    17,
-      19,    22,    25,    27,    30,    35,    37,    40,    43,    45,
-      48,    51,    52,    55,    56,    59,    62,    64,    68,    71,
-      74,    77,    81,    83,    85,    89,    92,    95,    98,   102,
-     104,   107,   111,   122,   126,   130,   133,   136,   138,   141,
-     145,   149,   151,   157,   161,   166,   170,   174,   180,   182,
-     184,   188,   191,   196,   200,   204,   206
-};
-
-/* YYRHS -- A `-1'-separated list of the rules' RHS.  */
-static const yytype_int8 yyrhs[] =
-{
-      51,     0,    -1,    68,    -1,    -1,    -1,    -1,    56,    -1,
-      60,    -1,    52,     6,    58,     7,    -1,    57,    -1,    52,
-      59,    -1,    58,    59,    -1,    59,    -1,    53,     3,    -1,
-      52,     6,    62,     7,    -1,    61,    -1,    52,    63,    -1,
-      62,    63,    -1,    63,    -1,    54,     5,    -1,    65,    66,
-      -1,    -1,    67,    66,    -1,    -1,     3,    55,    -1,    68,
-      69,    -1,    69,    -1,     8,     3,    64,    -1,     9,    10,
-      -1,     9,    18,    -1,     9,    37,    -1,    11,     3,    64,
-      -1,    12,    -1,    13,    -1,    14,     3,    64,    -1,    15,
-      60,    -1,    16,     3,    -1,    17,     3,    -1,    19,     3,
-      64,    -1,    20,    -1,    21,     3,    -1,    22,     3,    64,
-      -1,    23,     5,     5,     5,     5,     5,     5,     5,     5,
-       5,    -1,    24,     3,    64,    -1,    25,     3,    64,    -1,
-      26,     3,    -1,    27,     3,    -1,    28,    -1,    29,     3,
-      -1,    30,     3,    64,    -1,    31,     3,    64,    -1,    32,
-      -1,    33,     5,     5,     5,     5,    -1,    34,     3,    64,
-      -1,    35,     5,     5,     5,    -1,    36,     3,    64,    -1,
-      38,     3,    64,    -1,    39,     3,     3,     3,    64,    -1,
-      40,    -1,    41,    -1,    42,     5,     5,    -1,    43,    60,
-      -1,    44,     5,     5,     5,    -1,    46,     3,    64,    -1,
-      45,     3,    64,    -1,    47,    -1,    48,    -1
-};
-
-/* YYRLINE[YYN] -- source line where rule number YYN was defined.  */
-static const yytype_uint16 yyrline[] =
-{
-       0,   171,   171,   177,   185,   193,   201,   207,   214,   221,
-     229,   235,   240,   246,   254,   261,   269,   275,   280,   286,
-     294,   300,   313,   319,   324,   332,   337,   343,   352,   358,
-     364,   370,   379,   385,   391,   400,   408,   414,   420,   429,
-     435,   441,   450,   456,   465,   474,   480,   486,   492,   498,
-     507,   516,   522,   528,   537,   543,   552,   561,   570,   576,
-     582,   588,   596,   602,   611,   620,   626
-};
-#endif
-
-#if YYDEBUG || YYERROR_VERBOSE || YYTOKEN_TABLE
-/* YYTNAME[SYMBOL-NUM] -- String name of the symbol SYMBOL-NUM.
-   First, the terminals, then, starting at YYNTOKENS, nonterminals.  */
-static const char *const yytname[] =
-{
-  "$end", "error", "$undefined", "STRING", "ID", "NUM", "LBRACK",
-  "RBRACK", "ACCELERATOR", "ACTIVETRANSFORM", "ALL", "AREALIGHTSOURCE",
-  "ATTRIBUTEBEGIN", "ATTRIBUTEEND", "CAMERA", "CONCATTRANSFORM",
-  "COORDINATESYSTEM", "COORDSYSTRANSFORM", "ENDTIME", "FILM", "IDENTITY",
-  "INCLUDE", "LIGHTSOURCE", "LOOKAT", "MAKENAMEDMATERIAL", "MATERIAL",
-  "NAMEDMATERIAL", "OBJECTBEGIN", "OBJECTEND", "OBJECTINSTANCE",
-  "PIXELFILTER", "RENDERER", "REVERSEORIENTATION", "ROTATE", "SAMPLER",
-  "SCALE", "SHAPE", "STARTTIME", "SURFACEINTEGRATOR", "TEXTURE",
-  "TRANSFORMBEGIN", "TRANSFORMEND", "TRANSFORMTIMES", "TRANSFORM",
-  "TRANSLATE", "VOLUME", "VOLUMEINTEGRATOR", "WORLDBEGIN", "WORLDEND",
-  "HIGH_PRECEDENCE", "$accept", "start", "array_init", "string_array_init",
-  "num_array_init", "array", "string_array", "single_element_string_array",
-  "string_list", "string_list_entry", "num_array",
-  "single_element_num_array", "num_list", "num_list_entry", "paramlist",
-  "paramlist_init", "paramlist_contents", "paramlist_entry",
-  "pbrt_stmt_list", "pbrt_stmt", 0
-};
-#endif
-
-# ifdef YYPRINT
-/* YYTOKNUM[YYLEX-NUM] -- Internal token number corresponding to
-   token YYLEX-NUM.  */
-static const yytype_uint16 yytoknum[] =
-{
-       0,   256,   257,   258,   259,   260,   261,   262,   263,   264,
-     265,   266,   267,   268,   269,   270,   271,   272,   273,   274,
-     275,   276,   277,   278,   279,   280,   281,   282,   283,   284,
-     285,   286,   287,   288,   289,   290,   291,   292,   293,   294,
-     295,   296,   297,   298,   299,   300,   301,   302,   303,   304
-};
-# endif
-
-/* YYR1[YYN] -- Symbol number of symbol that rule YYN derives.  */
-static const yytype_uint8 yyr1[] =
-{
-       0,    50,    51,    52,    53,    54,    55,    55,    56,    56,
-      57,    58,    58,    59,    60,    60,    61,    62,    62,    63,
-      64,    65,    66,    66,    67,    68,    68,    69,    69,    69,
-      69,    69,    69,    69,    69,    69,    69,    69,    69,    69,
-      69,    69,    69,    69,    69,    69,    69,    69,    69,    69,
-      69,    69,    69,    69,    69,    69,    69,    69,    69,    69,
-      69,    69,    69,    69,    69,    69,    69
-};
-
-/* YYR2[YYN] -- Number of symbols composing right hand side of rule YYN.  */
-static const yytype_uint8 yyr2[] =
-{
-       0,     2,     1,     0,     0,     0,     1,     1,     4,     1,
-       2,     2,     1,     2,     4,     1,     2,     2,     1,     2,
-       2,     0,     2,     0,     2,     2,     1,     3,     2,     2,
-       2,     3,     1,     1,     3,     2,     2,     2,     3,     1,
-       2,     3,    10,     3,     3,     2,     2,     1,     2,     3,
-       3,     1,     5,     3,     4,     3,     3,     5,     1,     1,
-       3,     2,     4,     3,     3,     1,     1
-};
-
-/* YYDEFACT[STATE-NAME] -- Default reduction number in state STATE-NUM.
-   Performed when YYTABLE doesn't specify something else to do.  Zero
-   means the default is an error.  */
-static const yytype_uint8 yydefact[] =
-{
-       0,     0,     0,     0,    32,    33,     0,     3,     0,     0,
-       0,    39,     0,     0,     0,     0,     0,     0,     0,    47,
-       0,     0,     0,    51,     0,     0,     0,     0,     0,     0,
-      58,    59,     0,     3,     0,     0,     0,    65,    66,     0,
-       2,    26,    21,    28,    29,    30,    21,    21,     5,    35,
-      15,    36,    37,    21,    40,    21,     0,    21,    21,    45,
-      46,    48,    21,    21,     0,    21,     0,    21,    21,     0,
-       0,    61,     0,    21,    21,     1,    25,    27,    23,    31,
-      34,     5,     0,    16,    38,    41,     0,    43,    44,    49,
-      50,     0,    53,     0,    55,    56,     0,    60,     0,    64,
-      63,     3,    20,    23,     5,    18,    19,     0,     0,    54,
-      21,    62,     4,    24,     6,     9,     7,    22,    14,    17,
-       0,    52,    57,     4,     0,    10,     0,     4,    12,    13,
-       0,     8,    11,     0,     0,    42
-};
-
-/* YYDEFGOTO[NTERM-NUM].  */
-static const yytype_int8 yydefgoto[] =
-{
-      -1,    39,    48,   124,    82,   113,   114,   115,   127,   125,
-      49,    50,   104,    83,    77,    78,   102,   103,    40,    41
-};
-
-/* YYPACT[STATE-NUM] -- Index in YYTABLE of the portion describing
-   STATE-NUM.  */
-#define YYPACT_NINF -119
-static const yytype_int8 yypact[] =
-{
-      58,     1,    -4,     4,  -119,  -119,     8,  -119,    16,    18,
-      21,  -119,    22,    24,    25,    28,    29,    31,    32,  -119,
-      33,    34,    35,  -119,    36,    37,    38,    39,    41,    43,
-    -119,  -119,    42,  -119,    44,    45,    47,  -119,  -119,    51,
-      58,  -119,  -119,  -119,  -119,  -119,  -119,  -119,    46,  -119,
-    -119,  -119,  -119,  -119,  -119,  -119,    48,  -119,  -119,  -119,
-    -119,  -119,  -119,  -119,    49,  -119,    50,  -119,  -119,    53,
-      52,  -119,    54,  -119,  -119,  -119,  -119,  -119,    55,  -119,
-    -119,  -119,    56,  -119,  -119,  -119,    57,  -119,  -119,  -119,
-    -119,    59,  -119,    71,  -119,  -119,    60,  -119,    90,  -119,
-    -119,  -119,  -119,    55,   100,  -119,  -119,   103,   104,  -119,
-    -119,  -119,    10,  -119,  -119,  -119,  -119,  -119,  -119,  -119,
-     105,  -119,  -119,   106,   109,  -119,   108,   107,  -119,  -119,
-     110,  -119,  -119,   111,   112,  -119
-};
-
-/* YYPGOTO[NTERM-NUM].  */
-static const yytype_int8 yypgoto[] =
-{
-    -119,  -119,   -62,  -119,  -119,  -119,  -119,  -119,  -119,  -118,
-     -33,  -119,  -119,   -78,   -45,  -119,   -43,  -119,  -119,    78
-};
-
-/* YYTABLE[YYPACT[STATE-NUM]].  What to do in state STATE-NUM.  If
-   positive, shift that token.  If negative, reduce the rule which
-   number is the opposite.  If YYTABLE_NINF, syntax error.  */
-#define YYTABLE_NINF -6
-static const yytype_int16 yytable[] =
-{
-      71,    79,    80,   105,    42,   128,    43,    46,    84,   132,
-      85,    47,    87,    88,    44,    -5,   123,    89,    90,    51,
-      92,    52,    94,    95,    53,    54,   119,    55,    99,   100,
-      56,    57,    58,    45,    59,    60,    61,    62,    63,   112,
-      65,    64,    67,    66,    68,   105,    69,    70,    73,    72,
-      74,    75,    81,    86,    91,    93,    96,    97,   101,    98,
-     117,   106,   107,   110,   108,   122,     1,     2,   116,     3,
-       4,     5,     6,     7,     8,     9,   109,    10,    11,    12,
-      13,    14,    15,    16,    17,    18,    19,    20,    21,    22,
-      23,    24,    25,    26,    27,   111,    28,    29,    30,    31,
-      32,    33,    34,    35,    36,    37,    38,   118,   120,   121,
-     126,    -5,   129,   130,   131,   133,   134,   135,    76
-};
-
-#define yypact_value_is_default(yystate) \
-  ((yystate) == (-119))
-
-#define yytable_value_is_error(yytable_value) \
-  YYID (0)
-
-static const yytype_uint8 yycheck[] =
-{
-      33,    46,    47,    81,     3,   123,    10,     3,    53,   127,
-      55,     3,    57,    58,    18,     5,     6,    62,    63,     3,
-      65,     3,    67,    68,     3,     3,   104,     3,    73,    74,
-       5,     3,     3,    37,     3,     3,     3,     3,     3,   101,
-       3,     5,     3,     5,     3,   123,     3,     5,     3,     5,
-       3,     0,     6,     5,     5,     5,     3,     5,     3,     5,
-     103,     5,     5,     3,     5,   110,     8,     9,   101,    11,
-      12,    13,    14,    15,    16,    17,     5,    19,    20,    21,
-      22,    23,    24,    25,    26,    27,    28,    29,    30,    31,
-      32,    33,    34,    35,    36,     5,    38,    39,    40,    41,
-      42,    43,    44,    45,    46,    47,    48,     7,     5,     5,
-       5,     5,     3,     5,     7,     5,     5,     5,    40
-};
-
-/* YYSTOS[STATE-NUM] -- The (internal number of the) accessing
-   symbol of state STATE-NUM.  */
-static const yytype_uint8 yystos[] =
-{
-       0,     8,     9,    11,    12,    13,    14,    15,    16,    17,
-      19,    20,    21,    22,    23,    24,    25,    26,    27,    28,
-      29,    30,    31,    32,    33,    34,    35,    36,    38,    39,
-      40,    41,    42,    43,    44,    45,    46,    47,    48,    51,
-      68,    69,     3,    10,    18,    37,     3,     3,    52,    60,
-      61,     3,     3,     3,     3,     3,     5,     3,     3,     3,
-       3,     3,     3,     3,     5,     3,     5,     3,     3,     3,
-       5,    60,     5,     3,     3,     0,    69,    64,    65,    64,
-      64,     6,    54,    63,    64,    64,     5,    64,    64,    64,
-      64,     5,    64,     5,    64,    64,     3,     5,     5,    64,
-      64,     3,    66,    67,    62,    63,     5,     5,     5,     5,
-       3,     5,    52,    55,    56,    57,    60,    66,     7,    63,
-       5,     5,    64,     6,    53,    59,     5,    58,    59,     3,
-       5,     7,    59,     5,     5,     5
-};
-
-#define yyerrok		(yyerrstatus = 0)
-#define yyclearin	(yychar = YYEMPTY)
-#define YYEMPTY		(-2)
-#define YYEOF		0
-
-#define YYACCEPT	goto yyacceptlab
-#define YYABORT		goto yyabortlab
-#define YYERROR		goto yyerrorlab
-
-
-/* Like YYERROR except do call yyerror.  This remains here temporarily
-   to ease the transition to the new meaning of YYERROR, for GCC.
-   Once GCC version 2 has supplanted version 1, this can go.  However,
-   YYFAIL appears to be in use.  Nevertheless, it is formally deprecated
-   in Bison 2.4.2's NEWS entry, where a plan to phase it out is
-   discussed.  */
-
-#define YYFAIL		goto yyerrlab
-#if defined YYFAIL
-  /* This is here to suppress warnings from the GCC cpp's
-     -Wunused-macros.  Normally we don't worry about that warning, but
-     some users do, and we want to make it easy for users to remove
-     YYFAIL uses, which will produce warnings from Bison 2.5.  */
-#endif
-
-#define YYRECOVERING()  (!!yyerrstatus)
-
-#define YYBACKUP(Token, Value)					\
-do								\
-  if (yychar == YYEMPTY && yylen == 1)				\
-    {								\
-      yychar = (Token);						\
-      yylval = (Value);						\
-      YYPOPSTACK (1);						\
-      goto yybackup;						\
-    }								\
-  else								\
-    {								\
-      yyerror (YY_("syntax error: cannot back up")); \
-      YYERROR;							\
-    }								\
-while (YYID (0))
-
-
-#define YYTERROR	1
-#define YYERRCODE	256
-
-
-/* YYLLOC_DEFAULT -- Set CURRENT to span from RHS[1] to RHS[N].
-   If N is 0, then set CURRENT to the empty location which ends
-   the previous symbol: RHS[0] (always defined).  */
-
-#define YYRHSLOC(Rhs, K) ((Rhs)[K])
-#ifndef YYLLOC_DEFAULT
-# define YYLLOC_DEFAULT(Current, Rhs, N)				\
-    do									\
-      if (YYID (N))                                                    \
-	{								\
-	  (Current).first_line   = YYRHSLOC (Rhs, 1).first_line;	\
-	  (Current).first_column = YYRHSLOC (Rhs, 1).first_column;	\
-	  (Current).last_line    = YYRHSLOC (Rhs, N).last_line;		\
-	  (Current).last_column  = YYRHSLOC (Rhs, N).last_column;	\
-	}								\
-      else								\
-	{								\
-	  (Current).first_line   = (Current).last_line   =		\
-	    YYRHSLOC (Rhs, 0).last_line;				\
-	  (Current).first_column = (Current).last_column =		\
-	    YYRHSLOC (Rhs, 0).last_column;				\
-	}								\
-    while (YYID (0))
-#endif
-
-
-/* This macro is provided for backward compatibility. */
-
-#ifndef YY_LOCATION_PRINT
-# define YY_LOCATION_PRINT(File, Loc) ((void) 0)
-#endif
-
-
-/* YYLEX -- calling `yylex' with the right arguments.  */
-
-#ifdef YYLEX_PARAM
-# define YYLEX yylex (YYLEX_PARAM)
-#else
-# define YYLEX yylex ()
-#endif
-
-/* Enable debugging if requested.  */
-#if YYDEBUG
-
-# ifndef YYFPRINTF
-#  include <stdio.h> /* INFRINGES ON USER NAME SPACE */
-#  define YYFPRINTF fprintf
-# endif
-
-# define YYDPRINTF(Args)			\
-do {						\
-  if (yydebug)					\
-    YYFPRINTF Args;				\
-} while (YYID (0))
-
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)			  \
-do {									  \
-  if (yydebug)								  \
-    {									  \
-      YYFPRINTF (stderr, "%s ", Title);					  \
-      yy_symbol_print (stderr,						  \
-		  Type, Value); \
-      YYFPRINTF (stderr, "\n");						  \
-    }									  \
-} while (YYID (0))
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_value_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_value_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (!yyvaluep)
-    return;
-# ifdef YYPRINT
-  if (yytype < YYNTOKENS)
-    YYPRINT (yyoutput, yytoknum[yytype], *yyvaluep);
-# else
-  YYUSE (yyoutput);
-# endif
-  switch (yytype)
-    {
-      default:
-	break;
-    }
-}
-
-
-/*--------------------------------.
-| Print this symbol on YYOUTPUT.  |
-`--------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_symbol_print (FILE *yyoutput, int yytype, YYSTYPE const * const yyvaluep)
-#else
-static void
-yy_symbol_print (yyoutput, yytype, yyvaluep)
-    FILE *yyoutput;
-    int yytype;
-    YYSTYPE const * const yyvaluep;
-#endif
-{
-  if (yytype < YYNTOKENS)
-    YYFPRINTF (yyoutput, "token %s (", yytname[yytype]);
-  else
-    YYFPRINTF (yyoutput, "nterm %s (", yytname[yytype]);
-
-  yy_symbol_value_print (yyoutput, yytype, yyvaluep);
-  YYFPRINTF (yyoutput, ")");
-}
-
-/*------------------------------------------------------------------.
-| yy_stack_print -- Print the state stack from its BOTTOM up to its |
-| TOP (included).                                                   |
-`------------------------------------------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_stack_print (yytype_int16 *yybottom, yytype_int16 *yytop)
-#else
-static void
-yy_stack_print (yybottom, yytop)
-    yytype_int16 *yybottom;
-    yytype_int16 *yytop;
-#endif
-{
-  YYFPRINTF (stderr, "Stack now");
-  for (; yybottom <= yytop; yybottom++)
-    {
-      int yybot = *yybottom;
-      YYFPRINTF (stderr, " %d", yybot);
-    }
-  YYFPRINTF (stderr, "\n");
-}
-
-# define YY_STACK_PRINT(Bottom, Top)				\
-do {								\
-  if (yydebug)							\
-    yy_stack_print ((Bottom), (Top));				\
-} while (YYID (0))
-
-
-/*------------------------------------------------.
-| Report that the YYRULE is going to be reduced.  |
-`------------------------------------------------*/
-
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yy_reduce_print (YYSTYPE *yyvsp, int yyrule)
-#else
-static void
-yy_reduce_print (yyvsp, yyrule)
-    YYSTYPE *yyvsp;
-    int yyrule;
-#endif
-{
-  int yynrhs = yyr2[yyrule];
-  int yyi;
-  unsigned long int yylno = yyrline[yyrule];
-  YYFPRINTF (stderr, "Reducing stack by rule %d (line %lu):\n",
-	     yyrule - 1, yylno);
-  /* The symbols being reduced.  */
-  for (yyi = 0; yyi < yynrhs; yyi++)
-    {
-      YYFPRINTF (stderr, "   $%d = ", yyi + 1);
-      yy_symbol_print (stderr, yyrhs[yyprhs[yyrule] + yyi],
-		       &(yyvsp[(yyi + 1) - (yynrhs)])
-		       		       );
-      YYFPRINTF (stderr, "\n");
-    }
-}
-
-# define YY_REDUCE_PRINT(Rule)		\
-do {					\
-  if (yydebug)				\
-    yy_reduce_print (yyvsp, Rule); \
-} while (YYID (0))
-
-/* Nonzero means print parse trace.  It is left uninitialized so that
-   multiple parsers can coexist.  */
-int yydebug;
-#else /* !YYDEBUG */
-# define YYDPRINTF(Args)
-# define YY_SYMBOL_PRINT(Title, Type, Value, Location)
-# define YY_STACK_PRINT(Bottom, Top)
-# define YY_REDUCE_PRINT(Rule)
-#endif /* !YYDEBUG */
-
-
-/* YYINITDEPTH -- initial size of the parser's stacks.  */
-#ifndef	YYINITDEPTH
-# define YYINITDEPTH 200
-#endif
-
-/* YYMAXDEPTH -- maximum size the stacks can grow to (effective only
-   if the built-in stack extension method is used).
-
-   Do not make this value too large; the results are undefined if
-   YYSTACK_ALLOC_MAXIMUM < YYSTACK_BYTES (YYMAXDEPTH)
-   evaluated with infinite-precision integer arithmetic.  */
-
-#ifndef YYMAXDEPTH
-# define YYMAXDEPTH 10000
-#endif
-
-
-#if YYERROR_VERBOSE
-
-# ifndef yystrlen
-#  if defined __GLIBC__ && defined _STRING_H
-#   define yystrlen strlen
-#  else
-/* Return the length of YYSTR.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static YYSIZE_T
-yystrlen (const char *yystr)
-#else
-static YYSIZE_T
-yystrlen (yystr)
-    const char *yystr;
-#endif
-{
-  YYSIZE_T yylen;
-  for (yylen = 0; yystr[yylen]; yylen++)
-    continue;
-  return yylen;
-}
-#  endif
-# endif
-
-# ifndef yystpcpy
-#  if defined __GLIBC__ && defined _STRING_H && defined _GNU_SOURCE
-#   define yystpcpy stpcpy
-#  else
-/* Copy YYSRC to YYDEST, returning the address of the terminating '\0' in
-   YYDEST.  */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static char *
-yystpcpy (char *yydest, const char *yysrc)
-#else
-static char *
-yystpcpy (yydest, yysrc)
-    char *yydest;
-    const char *yysrc;
-#endif
-{
-  char *yyd = yydest;
-  const char *yys = yysrc;
-
-  while ((*yyd++ = *yys++) != '\0')
-    continue;
-
-  return yyd - 1;
-}
-#  endif
-# endif
-
-# ifndef yytnamerr
-/* Copy to YYRES the contents of YYSTR after stripping away unnecessary
-   quotes and backslashes, so that it's suitable for yyerror.  The
-   heuristic is that double-quoting is unnecessary unless the string
-   contains an apostrophe, a comma, or backslash (other than
-   backslash-backslash).  YYSTR is taken from yytname.  If YYRES is
-   null, do not copy; instead, return the length of what the result
-   would have been.  */
-static YYSIZE_T
-yytnamerr (char *yyres, const char *yystr)
-{
-  if (*yystr == '"')
-    {
-      YYSIZE_T yyn = 0;
-      char const *yyp = yystr;
-
-      for (;;)
-	switch (*++yyp)
-	  {
-	  case '\'':
-	  case ',':
-	    goto do_not_strip_quotes;
-
-	  case '\\':
-	    if (*++yyp != '\\')
-	      goto do_not_strip_quotes;
-	    /* Fall through.  */
-	  default:
-	    if (yyres)
-	      yyres[yyn] = *yyp;
-	    yyn++;
-	    break;
-
-	  case '"':
-	    if (yyres)
-	      yyres[yyn] = '\0';
-	    return yyn;
-	  }
-    do_not_strip_quotes: ;
-    }
-
-  if (! yyres)
-    return yystrlen (yystr);
-
-  return yystpcpy (yyres, yystr) - yyres;
-}
-# endif
-
-/* Copy into *YYMSG, which is of size *YYMSG_ALLOC, an error message
-   about the unexpected token YYTOKEN for the state stack whose top is
-   YYSSP.
-
-   Return 0 if *YYMSG was successfully written.  Return 1 if *YYMSG is
-   not large enough to hold the message.  In that case, also set
-   *YYMSG_ALLOC to the required number of bytes.  Return 2 if the
-   required number of bytes is too large to store.  */
-static int
-yysyntax_error (YYSIZE_T *yymsg_alloc, char **yymsg,
-                yytype_int16 *yyssp, int yytoken)
-{
-  YYSIZE_T yysize0 = yytnamerr (0, yytname[yytoken]);
-  YYSIZE_T yysize = yysize0;
-  YYSIZE_T yysize1;
-  enum { YYERROR_VERBOSE_ARGS_MAXIMUM = 5 };
-  /* Internationalized format string. */
-  const char *yyformat = 0;
-  /* Arguments of yyformat. */
-  char const *yyarg[YYERROR_VERBOSE_ARGS_MAXIMUM];
-  /* Number of reported tokens (one for the "unexpected", one per
-     "expected"). */
-  int yycount = 0;
-
-  /* There are many possibilities here to consider:
-     - Assume YYFAIL is not used.  It's too flawed to consider.  See
-       <http://lists.gnu.org/archive/html/bison-patches/2009-12/msg00024.html>
-       for details.  YYERROR is fine as it does not invoke this
-       function.
-     - If this state is a consistent state with a default action, then
-       the only way this function was invoked is if the default action
-       is an error action.  In that case, don't check for expected
-       tokens because there are none.
-     - The only way there can be no lookahead present (in yychar) is if
-       this state is a consistent state with a default action.  Thus,
-       detecting the absence of a lookahead is sufficient to determine
-       that there is no unexpected or expected token to report.  In that
-       case, just report a simple "syntax error".
-     - Don't assume there isn't a lookahead just because this state is a
-       consistent state with a default action.  There might have been a
-       previous inconsistent state, consistent state with a non-default
-       action, or user semantic action that manipulated yychar.
-     - Of course, the expected token list depends on states to have
-       correct lookahead information, and it depends on the parser not
-       to perform extra reductions after fetching a lookahead from the
-       scanner and before detecting a syntax error.  Thus, state merging
-       (from LALR or IELR) and default reductions corrupt the expected
-       token list.  However, the list is correct for canonical LR with
-       one exception: it will still contain any token that will not be
-       accepted due to an error action in a later state.
-  */
-  if (yytoken != YYEMPTY)
-    {
-      int yyn = yypact[*yyssp];
-      yyarg[yycount++] = yytname[yytoken];
-      if (!yypact_value_is_default (yyn))
-        {
-          /* Start YYX at -YYN if negative to avoid negative indexes in
-             YYCHECK.  In other words, skip the first -YYN actions for
-             this state because they are default actions.  */
-          int yyxbegin = yyn < 0 ? -yyn : 0;
-          /* Stay within bounds of both yycheck and yytname.  */
-          int yychecklim = YYLAST - yyn + 1;
-          int yyxend = yychecklim < YYNTOKENS ? yychecklim : YYNTOKENS;
-          int yyx;
-
-          for (yyx = yyxbegin; yyx < yyxend; ++yyx)
-            if (yycheck[yyx + yyn] == yyx && yyx != YYTERROR
-                && !yytable_value_is_error (yytable[yyx + yyn]))
-              {
-                if (yycount == YYERROR_VERBOSE_ARGS_MAXIMUM)
-                  {
-                    yycount = 1;
-                    yysize = yysize0;
-                    break;
-                  }
-                yyarg[yycount++] = yytname[yyx];
-                yysize1 = yysize + yytnamerr (0, yytname[yyx]);
-                if (! (yysize <= yysize1
-                       && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-                  return 2;
-                yysize = yysize1;
-              }
-        }
-    }
-
-  switch (yycount)
-    {
-# define YYCASE_(N, S)                      \
-      case N:                               \
-        yyformat = S;                       \
-      break
-      YYCASE_(0, YY_("syntax error"));
-      YYCASE_(1, YY_("syntax error, unexpected %s"));
-      YYCASE_(2, YY_("syntax error, unexpected %s, expecting %s"));
-      YYCASE_(3, YY_("syntax error, unexpected %s, expecting %s or %s"));
-      YYCASE_(4, YY_("syntax error, unexpected %s, expecting %s or %s or %s"));
-      YYCASE_(5, YY_("syntax error, unexpected %s, expecting %s or %s or %s or %s"));
-# undef YYCASE_
-    }
-
-  yysize1 = yysize + yystrlen (yyformat);
-  if (! (yysize <= yysize1 && yysize1 <= YYSTACK_ALLOC_MAXIMUM))
-    return 2;
-  yysize = yysize1;
-
-  if (*yymsg_alloc < yysize)
-    {
-      *yymsg_alloc = 2 * yysize;
-      if (! (yysize <= *yymsg_alloc
-             && *yymsg_alloc <= YYSTACK_ALLOC_MAXIMUM))
-        *yymsg_alloc = YYSTACK_ALLOC_MAXIMUM;
-      return 1;
-    }
-
-  /* Avoid sprintf, as that infringes on the user's name space.
-     Don't have undefined behavior even if the translation
-     produced a string with the wrong number of "%s"s.  */
-  {
-    char *yyp = *yymsg;
-    int yyi = 0;
-    while ((*yyp = *yyformat) != '\0')
-      if (*yyp == '%' && yyformat[1] == 's' && yyi < yycount)
-        {
-          yyp += yytnamerr (yyp, yyarg[yyi++]);
-          yyformat += 2;
-        }
-      else
-        {
-          yyp++;
-          yyformat++;
-        }
-  }
-  return 0;
-}
-#endif /* YYERROR_VERBOSE */
-
-/*-----------------------------------------------.
-| Release the memory associated to this symbol.  |
-`-----------------------------------------------*/
-
-/*ARGSUSED*/
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-static void
-yydestruct (const char *yymsg, int yytype, YYSTYPE *yyvaluep)
-#else
-static void
-yydestruct (yymsg, yytype, yyvaluep)
-    const char *yymsg;
-    int yytype;
-    YYSTYPE *yyvaluep;
-#endif
-{
-  YYUSE (yyvaluep);
-
-  if (!yymsg)
-    yymsg = "Deleting";
-  YY_SYMBOL_PRINT (yymsg, yytype, yyvaluep, yylocationp);
-
-  switch (yytype)
-    {
-
-      default:
-	break;
-    }
-}
-
-
-/* Prevent warnings from -Wmissing-prototypes.  */
-#ifdef YYPARSE_PARAM
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void *YYPARSE_PARAM);
-#else
-int yyparse ();
-#endif
-#else /* ! YYPARSE_PARAM */
-#if defined __STDC__ || defined __cplusplus
-int yyparse (void);
-#else
-int yyparse ();
-#endif
-#endif /* ! YYPARSE_PARAM */
-
-
-/* The lookahead symbol.  */
-int yychar;
-
-/* The semantic value of the lookahead symbol.  */
-YYSTYPE yylval;
-
-/* Number of syntax errors so far.  */
-int yynerrs;
-
-
-/*----------.
-| yyparse.  |
-`----------*/
-
-#ifdef YYPARSE_PARAM
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void *YYPARSE_PARAM)
-#else
-int
-yyparse (YYPARSE_PARAM)
-    void *YYPARSE_PARAM;
-#endif
-#else /* ! YYPARSE_PARAM */
-#if (defined __STDC__ || defined __C99__FUNC__ \
-     || defined __cplusplus || defined _MSC_VER)
-int
-yyparse (void)
-#else
-int
-yyparse ()
-
-#endif
-#endif
-{
-    int yystate;
-    /* Number of tokens to shift before error messages enabled.  */
-    int yyerrstatus;
-
-    /* The stacks and their tools:
-       `yyss': related to states.
-       `yyvs': related to semantic values.
-
-       Refer to the stacks thru separate pointers, to allow yyoverflow
-       to reallocate them elsewhere.  */
-
-    /* The state stack.  */
-    yytype_int16 yyssa[YYINITDEPTH];
-    yytype_int16 *yyss;
-    yytype_int16 *yyssp;
-
-    /* The semantic value stack.  */
-    YYSTYPE yyvsa[YYINITDEPTH];
-    YYSTYPE *yyvs;
-    YYSTYPE *yyvsp;
-
-    YYSIZE_T yystacksize;
-
-  int yyn;
-  int yyresult;
-  /* Lookahead token as an internal (translated) token number.  */
-  int yytoken;
-  /* The variables used to return semantic value and location from the
-     action routines.  */
-  YYSTYPE yyval;
-
-#if YYERROR_VERBOSE
-  /* Buffer for error messages, and its allocated size.  */
-  char yymsgbuf[128];
-  char *yymsg = yymsgbuf;
-  YYSIZE_T yymsg_alloc = sizeof yymsgbuf;
-#endif
-
-#define YYPOPSTACK(N)   (yyvsp -= (N), yyssp -= (N))
-
-  /* The number of symbols on the RHS of the reduced rule.
-     Keep to zero when no symbol should be popped.  */
-  int yylen = 0;
-
-  yytoken = 0;
-  yyss = yyssa;
-  yyvs = yyvsa;
-  yystacksize = YYINITDEPTH;
-
-  YYDPRINTF ((stderr, "Starting parse\n"));
-
-  yystate = 0;
-  yyerrstatus = 0;
-  yynerrs = 0;
-  yychar = YYEMPTY; /* Cause a token to be read.  */
-
-  /* Initialize stack pointers.
-     Waste one element of value and location stack
-     so that they stay on the same level as the state stack.
-     The wasted elements are never initialized.  */
-  yyssp = yyss;
-  yyvsp = yyvs;
-
-  goto yysetstate;
-
-/*------------------------------------------------------------.
-| yynewstate -- Push a new state, which is found in yystate.  |
-`------------------------------------------------------------*/
- yynewstate:
-  /* In all cases, when you get here, the value and location stacks
-     have just been pushed.  So pushing a state here evens the stacks.  */
-  yyssp++;
-
- yysetstate:
-  *yyssp = yystate;
-
-  if (yyss + yystacksize - 1 <= yyssp)
-    {
-      /* Get the current used size of the three stacks, in elements.  */
-      YYSIZE_T yysize = yyssp - yyss + 1;
-
-#ifdef yyoverflow
-      {
-	/* Give user a chance to reallocate the stack.  Use copies of
-	   these so that the &'s don't force the real ones into
-	   memory.  */
-	YYSTYPE *yyvs1 = yyvs;
-	yytype_int16 *yyss1 = yyss;
-
-	/* Each stack pointer address is followed by the size of the
-	   data in use in that stack, in bytes.  This used to be a
-	   conditional around just the two extra args, but that might
-	   be undefined if yyoverflow is a macro.  */
-	yyoverflow (YY_("memory exhausted"),
-		    &yyss1, yysize * sizeof (*yyssp),
-		    &yyvs1, yysize * sizeof (*yyvsp),
-		    &yystacksize);
-
-	yyss = yyss1;
-	yyvs = yyvs1;
-      }
-#else /* no yyoverflow */
-# ifndef YYSTACK_RELOCATE
-      goto yyexhaustedlab;
-# else
-      /* Extend the stack our own way.  */
-      if (YYMAXDEPTH <= yystacksize)
-	goto yyexhaustedlab;
-      yystacksize *= 2;
-      if (YYMAXDEPTH < yystacksize)
-	yystacksize = YYMAXDEPTH;
-
-      {
-	yytype_int16 *yyss1 = yyss;
-	union yyalloc *yyptr =
-	  (union yyalloc *) YYSTACK_ALLOC (YYSTACK_BYTES (yystacksize));
-	if (! yyptr)
-	  goto yyexhaustedlab;
-	YYSTACK_RELOCATE (yyss_alloc, yyss);
-	YYSTACK_RELOCATE (yyvs_alloc, yyvs);
-#  undef YYSTACK_RELOCATE
-	if (yyss1 != yyssa)
-	  YYSTACK_FREE (yyss1);
-      }
-# endif
-#endif /* no yyoverflow */
-
-      yyssp = yyss + yysize - 1;
-      yyvsp = yyvs + yysize - 1;
-
-      YYDPRINTF ((stderr, "Stack size increased to %lu\n",
-		  (unsigned long int) yystacksize));
-
-      if (yyss + yystacksize - 1 <= yyssp)
-	YYABORT;
-    }
-
-  YYDPRINTF ((stderr, "Entering state %d\n", yystate));
-
-  if (yystate == YYFINAL)
-    YYACCEPT;
-
-  goto yybackup;
-
-/*-----------.
-| yybackup.  |
-`-----------*/
-yybackup:
-
-  /* Do appropriate processing given the current state.  Read a
-     lookahead token if we need one and don't already have one.  */
-
-  /* First try to decide what to do without reference to lookahead token.  */
-  yyn = yypact[yystate];
-  if (yypact_value_is_default (yyn))
-    goto yydefault;
-
-  /* Not known => get a lookahead token if don't already have one.  */
-
-  /* YYCHAR is either YYEMPTY or YYEOF or a valid lookahead symbol.  */
-  if (yychar == YYEMPTY)
-    {
-      YYDPRINTF ((stderr, "Reading a token: "));
-      yychar = YYLEX;
-    }
-
-  if (yychar <= YYEOF)
-    {
-      yychar = yytoken = YYEOF;
-      YYDPRINTF ((stderr, "Now at end of input.\n"));
-    }
-  else
-    {
-      yytoken = YYTRANSLATE (yychar);
-      YY_SYMBOL_PRINT ("Next token is", yytoken, &yylval, &yylloc);
-    }
-
-  /* If the proper action on seeing token YYTOKEN is to reduce or to
-     detect an error, take that action.  */
-  yyn += yytoken;
-  if (yyn < 0 || YYLAST < yyn || yycheck[yyn] != yytoken)
-    goto yydefault;
-  yyn = yytable[yyn];
-  if (yyn <= 0)
-    {
-      if (yytable_value_is_error (yyn))
-        goto yyerrlab;
-      yyn = -yyn;
-      goto yyreduce;
-    }
-
-  /* Count tokens shifted since error; after three, turn off error
-     status.  */
-  if (yyerrstatus)
-    yyerrstatus--;
-
-  /* Shift the lookahead token.  */
-  YY_SYMBOL_PRINT ("Shifting", yytoken, &yylval, &yylloc);
-
-  /* Discard the shifted token.  */
-  yychar = YYEMPTY;
-
-  yystate = yyn;
-  *++yyvsp = yylval;
-
-  goto yynewstate;
-
-
-/*-----------------------------------------------------------.
-| yydefault -- do the default action for the current state.  |
-`-----------------------------------------------------------*/
-yydefault:
-  yyn = yydefact[yystate];
-  if (yyn == 0)
-    goto yyerrlab;
-  goto yyreduce;
-
-
-/*-----------------------------.
-| yyreduce -- Do a reduction.  |
-`-----------------------------*/
-yyreduce:
-  /* yyn is the number of a rule to reduce with.  */
-  yylen = yyr2[yyn];
-
-  /* If YYLEN is nonzero, implement the default value of the action:
-     `$$ = $1'.
-
-     Otherwise, the following line sets YYVAL to garbage.
-     This behavior is undocumented and Bison
-     users should not rely upon it.  Assigning to YYVAL
-     unconditionally makes the parser a bit smaller, and it avoids a
-     GCC warning that YYVAL may be used uninitialized.  */
-  yyval = yyvsp[1-yylen];
-
-
-  YY_REDUCE_PRINT (yyn);
-  switch (yyn)
-    {
-        case 2:
-
-/* Line 1821 of yacc.c  */
-#line 172 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 3:
-
-/* Line 1821 of yacc.c  */
-#line 178 "core/pbrtparse.yy"
-    {
-    if (cur_array) Severe("MUH");
-    cur_array = new ParamArray;
-}
-    break;
-
-  case 4:
-
-/* Line 1821 of yacc.c  */
-#line 186 "core/pbrtparse.yy"
-    {
-    cur_array->element_size = sizeof(const char *);
-    cur_array->isString = true;
-}
-    break;
-
-  case 5:
-
-/* Line 1821 of yacc.c  */
-#line 194 "core/pbrtparse.yy"
-    {
-    cur_array->element_size = sizeof(float);
-    cur_array->isString = false;
-}
-    break;
-
-  case 6:
-
-/* Line 1821 of yacc.c  */
-#line 202 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = (yyvsp[(1) - (1)].ribarray);
-}
-    break;
-
-  case 7:
-
-/* Line 1821 of yacc.c  */
-#line 208 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = (yyvsp[(1) - (1)].ribarray);
-}
-    break;
-
-  case 8:
-
-/* Line 1821 of yacc.c  */
-#line 215 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = cur_array;
-    cur_array = NULL;
-}
-    break;
-
-  case 9:
-
-/* Line 1821 of yacc.c  */
-#line 222 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = cur_array;
-    cur_array = NULL;
-}
-    break;
-
-  case 10:
-
-/* Line 1821 of yacc.c  */
-#line 230 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 11:
-
-/* Line 1821 of yacc.c  */
-#line 236 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 12:
-
-/* Line 1821 of yacc.c  */
-#line 241 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 13:
-
-/* Line 1821 of yacc.c  */
-#line 247 "core/pbrtparse.yy"
-    {
-    char *to_add = strdup((yyvsp[(2) - (2)].string));
-    AddArrayElement(&to_add);
-}
-    break;
-
-  case 14:
-
-/* Line 1821 of yacc.c  */
-#line 255 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = cur_array;
-    cur_array = NULL;
-}
-    break;
-
-  case 15:
-
-/* Line 1821 of yacc.c  */
-#line 262 "core/pbrtparse.yy"
-    {
-    (yyval.ribarray) = cur_array;
-    cur_array = NULL;
-}
-    break;
-
-  case 16:
-
-/* Line 1821 of yacc.c  */
-#line 270 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 17:
-
-/* Line 1821 of yacc.c  */
-#line 276 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 18:
-
-/* Line 1821 of yacc.c  */
-#line 281 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 19:
-
-/* Line 1821 of yacc.c  */
-#line 287 "core/pbrtparse.yy"
-    {
-    float to_add = (yyvsp[(2) - (2)].num);
-    AddArrayElement(&to_add);
-}
-    break;
-
-  case 20:
-
-/* Line 1821 of yacc.c  */
-#line 295 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 21:
-
-/* Line 1821 of yacc.c  */
-#line 301 "core/pbrtparse.yy"
-    {
-    for (uint32_t i = 0; i < cur_paramlist.size(); ++i) {
-        if (cur_paramlist[i].isString) {
-            for (uint32_t j = 0; j < (uint32_t)cur_paramlist[i].size; ++j)
-                free(((char **)cur_paramlist[i].arg)[j]);
-        }
-    }
-    cur_paramlist.erase(cur_paramlist.begin(), cur_paramlist.end());
-}
-    break;
-
-  case 22:
-
-/* Line 1821 of yacc.c  */
-#line 314 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 23:
-
-/* Line 1821 of yacc.c  */
-#line 319 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 24:
-
-/* Line 1821 of yacc.c  */
-#line 325 "core/pbrtparse.yy"
-    {
-    cur_paramlist.push_back(ParamListItem((yyvsp[(1) - (2)].string), (yyvsp[(2) - (2)].ribarray)));
-    ArrayFree((yyvsp[(2) - (2)].ribarray));
-}
-    break;
-
-  case 25:
-
-/* Line 1821 of yacc.c  */
-#line 333 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 26:
-
-/* Line 1821 of yacc.c  */
-#line 338 "core/pbrtparse.yy"
-    {
-}
-    break;
-
-  case 27:
-
-/* Line 1821 of yacc.c  */
-#line 344 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtAccelerator((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 28:
-
-/* Line 1821 of yacc.c  */
-#line 353 "core/pbrtparse.yy"
-    {
-    pbrtActiveTransformAll();
-}
-    break;
-
-  case 29:
-
-/* Line 1821 of yacc.c  */
-#line 359 "core/pbrtparse.yy"
-    {
-    pbrtActiveTransformEndTime();
-}
-    break;
-
-  case 30:
-
-/* Line 1821 of yacc.c  */
-#line 365 "core/pbrtparse.yy"
-    {
-    pbrtActiveTransformStartTime();
-}
-    break;
-
-  case 31:
-
-/* Line 1821 of yacc.c  */
-#line 371 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_ILLUMINANT);
-    pbrtAreaLightSource((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 32:
-
-/* Line 1821 of yacc.c  */
-#line 380 "core/pbrtparse.yy"
-    {
-    pbrtAttributeBegin();
-}
-    break;
-
-  case 33:
-
-/* Line 1821 of yacc.c  */
-#line 386 "core/pbrtparse.yy"
-    {
-    pbrtAttributeEnd();
-}
-    break;
-
-  case 34:
-
-/* Line 1821 of yacc.c  */
-#line 392 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtCamera((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 35:
-
-/* Line 1821 of yacc.c  */
-#line 401 "core/pbrtparse.yy"
-    {
-    if (VerifyArrayLength((yyvsp[(2) - (2)].ribarray), 16, "ConcatTransform"))
-        pbrtConcatTransform((float *) (yyvsp[(2) - (2)].ribarray)->array);
-    ArrayFree((yyvsp[(2) - (2)].ribarray));
-}
-    break;
-
-  case 36:
-
-/* Line 1821 of yacc.c  */
-#line 409 "core/pbrtparse.yy"
-    {
-    pbrtCoordinateSystem((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 37:
-
-/* Line 1821 of yacc.c  */
-#line 415 "core/pbrtparse.yy"
-    {
-    pbrtCoordSysTransform((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 38:
-
-/* Line 1821 of yacc.c  */
-#line 421 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtFilm((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 39:
-
-/* Line 1821 of yacc.c  */
-#line 430 "core/pbrtparse.yy"
-    {
-    pbrtIdentity();
-}
-    break;
-
-  case 40:
-
-/* Line 1821 of yacc.c  */
-#line 436 "core/pbrtparse.yy"
-    {
-  include_push((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 41:
-
-/* Line 1821 of yacc.c  */
-#line 442 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_ILLUMINANT);
-    pbrtLightSource((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 42:
-
-/* Line 1821 of yacc.c  */
-#line 451 "core/pbrtparse.yy"
-    {
-    pbrtLookAt((yyvsp[(2) - (10)].num), (yyvsp[(3) - (10)].num), (yyvsp[(4) - (10)].num), (yyvsp[(5) - (10)].num), (yyvsp[(6) - (10)].num), (yyvsp[(7) - (10)].num), (yyvsp[(8) - (10)].num), (yyvsp[(9) - (10)].num), (yyvsp[(10) - (10)].num));
-}
-    break;
-
-  case 43:
-
-/* Line 1821 of yacc.c  */
-#line 457 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtMakeNamedMaterial((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 44:
-
-/* Line 1821 of yacc.c  */
-#line 466 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtMaterial((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 45:
-
-/* Line 1821 of yacc.c  */
-#line 475 "core/pbrtparse.yy"
-    {
-    pbrtNamedMaterial((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 46:
-
-/* Line 1821 of yacc.c  */
-#line 481 "core/pbrtparse.yy"
-    {
-    pbrtObjectBegin((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 47:
-
-/* Line 1821 of yacc.c  */
-#line 487 "core/pbrtparse.yy"
-    {
-    pbrtObjectEnd();
-}
-    break;
-
-  case 48:
-
-/* Line 1821 of yacc.c  */
-#line 493 "core/pbrtparse.yy"
-    {
-    pbrtObjectInstance((yyvsp[(2) - (2)].string));
-}
-    break;
-
-  case 49:
-
-/* Line 1821 of yacc.c  */
-#line 499 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtPixelFilter((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 50:
-
-/* Line 1821 of yacc.c  */
-#line 508 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtRenderer((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 51:
-
-/* Line 1821 of yacc.c  */
-#line 517 "core/pbrtparse.yy"
-    {
-    pbrtReverseOrientation();
-}
-    break;
-
-  case 52:
-
-/* Line 1821 of yacc.c  */
-#line 523 "core/pbrtparse.yy"
-    {
-    pbrtRotate((yyvsp[(2) - (5)].num), (yyvsp[(3) - (5)].num), (yyvsp[(4) - (5)].num), (yyvsp[(5) - (5)].num));
-}
-    break;
-
-  case 53:
-
-/* Line 1821 of yacc.c  */
-#line 529 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtSampler((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 54:
-
-/* Line 1821 of yacc.c  */
-#line 538 "core/pbrtparse.yy"
-    {
-    pbrtScale((yyvsp[(2) - (4)].num), (yyvsp[(3) - (4)].num), (yyvsp[(4) - (4)].num));
-}
-    break;
-
-  case 55:
-
-/* Line 1821 of yacc.c  */
-#line 544 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtShape((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 56:
-
-/* Line 1821 of yacc.c  */
-#line 553 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtSurfaceIntegrator((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 57:
-
-/* Line 1821 of yacc.c  */
-#line 562 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtTexture((yyvsp[(2) - (5)].string), (yyvsp[(3) - (5)].string), (yyvsp[(4) - (5)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 58:
-
-/* Line 1821 of yacc.c  */
-#line 571 "core/pbrtparse.yy"
-    {
-    pbrtTransformBegin();
-}
-    break;
-
-  case 59:
-
-/* Line 1821 of yacc.c  */
-#line 577 "core/pbrtparse.yy"
-    {
-    pbrtTransformEnd();
-}
-    break;
-
-  case 60:
-
-/* Line 1821 of yacc.c  */
-#line 583 "core/pbrtparse.yy"
-    {
-    pbrtTransformTimes((yyvsp[(2) - (3)].num), (yyvsp[(3) - (3)].num));
-}
-    break;
-
-  case 61:
-
-/* Line 1821 of yacc.c  */
-#line 589 "core/pbrtparse.yy"
-    {
-    if (VerifyArrayLength( (yyvsp[(2) - (2)].ribarray), 16, "Transform" ))
-        pbrtTransform( (float *) (yyvsp[(2) - (2)].ribarray)->array );
-    ArrayFree((yyvsp[(2) - (2)].ribarray));
-}
-    break;
-
-  case 62:
-
-/* Line 1821 of yacc.c  */
-#line 597 "core/pbrtparse.yy"
-    {
-    pbrtTranslate((yyvsp[(2) - (4)].num), (yyvsp[(3) - (4)].num), (yyvsp[(4) - (4)].num));
-}
-    break;
-
-  case 63:
-
-/* Line 1821 of yacc.c  */
-#line 603 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtVolumeIntegrator((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 64:
-
-/* Line 1821 of yacc.c  */
-#line 612 "core/pbrtparse.yy"
-    {
-    ParamSet params;
-    InitParamSet(params, SPECTRUM_REFLECTANCE);
-    pbrtVolume((yyvsp[(2) - (3)].string), params);
-    FreeArgs();
-}
-    break;
-
-  case 65:
-
-/* Line 1821 of yacc.c  */
-#line 621 "core/pbrtparse.yy"
-    {
-    pbrtWorldBegin();
-}
-    break;
-
-  case 66:
-
-/* Line 1821 of yacc.c  */
-#line 627 "core/pbrtparse.yy"
-    {
-    pbrtWorldEnd();
-}
-    break;
-
-
-
-/* Line 1821 of yacc.c  */
-#line 2278 "core/pbrtparse.cpp"
-      default: break;
-    }
-  /* User semantic actions sometimes alter yychar, and that requires
-     that yytoken be updated with the new translation.  We take the
-     approach of translating immediately before every use of yytoken.
-     One alternative is translating here after every semantic action,
-     but that translation would be missed if the semantic action invokes
-     YYABORT, YYACCEPT, or YYERROR immediately after altering yychar or
-     if it invokes YYBACKUP.  In the case of YYABORT or YYACCEPT, an
-     incorrect destructor might then be invoked immediately.  In the
-     case of YYERROR or YYBACKUP, subsequent parser actions might lead
-     to an incorrect destructor call or verbose syntax error message
-     before the lookahead is translated.  */
-  YY_SYMBOL_PRINT ("-> $$ =", yyr1[yyn], &yyval, &yyloc);
-
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-
-  *++yyvsp = yyval;
-
-  /* Now `shift' the result of the reduction.  Determine what state
-     that goes to, based on the state we popped back to and the rule
-     number reduced by.  */
-
-  yyn = yyr1[yyn];
-
-  yystate = yypgoto[yyn - YYNTOKENS] + *yyssp;
-  if (0 <= yystate && yystate <= YYLAST && yycheck[yystate] == *yyssp)
-    yystate = yytable[yystate];
-  else
-    yystate = yydefgoto[yyn - YYNTOKENS];
-
-  goto yynewstate;
-
-
-/*------------------------------------.
-| yyerrlab -- here on detecting error |
-`------------------------------------*/
-yyerrlab:
-  /* Make sure we have latest lookahead translation.  See comments at
-     user semantic actions for why this is necessary.  */
-  yytoken = yychar == YYEMPTY ? YYEMPTY : YYTRANSLATE (yychar);
-
-  /* If not already recovering from an error, report this error.  */
-  if (!yyerrstatus)
-    {
-      ++yynerrs;
-#if ! YYERROR_VERBOSE
-      yyerror (YY_("syntax error"));
-#else
-# define YYSYNTAX_ERROR yysyntax_error (&yymsg_alloc, &yymsg, \
-                                        yyssp, yytoken)
-      {
-        char const *yymsgp = YY_("syntax error");
-        int yysyntax_error_status;
-        yysyntax_error_status = YYSYNTAX_ERROR;
-        if (yysyntax_error_status == 0)
-          yymsgp = yymsg;
-        else if (yysyntax_error_status == 1)
-          {
-            if (yymsg != yymsgbuf)
-              YYSTACK_FREE (yymsg);
-            yymsg = (char *) YYSTACK_ALLOC (yymsg_alloc);
-            if (!yymsg)
-              {
-                yymsg = yymsgbuf;
-                yymsg_alloc = sizeof yymsgbuf;
-                yysyntax_error_status = 2;
-              }
-            else
-              {
-                yysyntax_error_status = YYSYNTAX_ERROR;
-                yymsgp = yymsg;
-              }
-          }
-        yyerror (yymsgp);
-        if (yysyntax_error_status == 2)
-          goto yyexhaustedlab;
-      }
-# undef YYSYNTAX_ERROR
-#endif
-    }
-
-
-
-  if (yyerrstatus == 3)
-    {
-      /* If just tried and failed to reuse lookahead token after an
-	 error, discard it.  */
-
-      if (yychar <= YYEOF)
-	{
-	  /* Return failure if at end of input.  */
-	  if (yychar == YYEOF)
-	    YYABORT;
-	}
-      else
-	{
-	  yydestruct ("Error: discarding",
-		      yytoken, &yylval);
-	  yychar = YYEMPTY;
-	}
-    }
-
-  /* Else will try to reuse lookahead token after shifting the error
-     token.  */
-  goto yyerrlab1;
-
-
-/*---------------------------------------------------.
-| yyerrorlab -- error raised explicitly by YYERROR.  |
-`---------------------------------------------------*/
-yyerrorlab:
-
-  /* Pacify compilers like GCC when the user code never invokes
-     YYERROR and the label yyerrorlab therefore never appears in user
-     code.  */
-  if (/*CONSTCOND*/ 0)
-     goto yyerrorlab;
-
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYERROR.  */
-  YYPOPSTACK (yylen);
-  yylen = 0;
-  YY_STACK_PRINT (yyss, yyssp);
-  yystate = *yyssp;
-  goto yyerrlab1;
-
-
-/*-------------------------------------------------------------.
-| yyerrlab1 -- common code for both syntax error and YYERROR.  |
-`-------------------------------------------------------------*/
-yyerrlab1:
-  yyerrstatus = 3;	/* Each real token shifted decrements this.  */
-
-  for (;;)
-    {
-      yyn = yypact[yystate];
-      if (!yypact_value_is_default (yyn))
-	{
-	  yyn += YYTERROR;
-	  if (0 <= yyn && yyn <= YYLAST && yycheck[yyn] == YYTERROR)
-	    {
-	      yyn = yytable[yyn];
-	      if (0 < yyn)
-		break;
-	    }
-	}
-
-      /* Pop the current state because it cannot handle the error token.  */
-      if (yyssp == yyss)
-	YYABORT;
-
-
-      yydestruct ("Error: popping",
-		  yystos[yystate], yyvsp);
-      YYPOPSTACK (1);
-      yystate = *yyssp;
-      YY_STACK_PRINT (yyss, yyssp);
-    }
-
-  *++yyvsp = yylval;
-
-
-  /* Shift the error token.  */
-  YY_SYMBOL_PRINT ("Shifting", yystos[yyn], yyvsp, yylsp);
-
-  yystate = yyn;
-  goto yynewstate;
-
-
-/*-------------------------------------.
-| yyacceptlab -- YYACCEPT comes here.  |
-`-------------------------------------*/
-yyacceptlab:
-  yyresult = 0;
-  goto yyreturn;
-
-/*-----------------------------------.
-| yyabortlab -- YYABORT comes here.  |
-`-----------------------------------*/
-yyabortlab:
-  yyresult = 1;
-  goto yyreturn;
-
-#if !defined(yyoverflow) || YYERROR_VERBOSE
-/*-------------------------------------------------.
-| yyexhaustedlab -- memory exhaustion comes here.  |
-`-------------------------------------------------*/
-yyexhaustedlab:
-  yyerror (YY_("memory exhausted"));
-  yyresult = 2;
-  /* Fall through.  */
-#endif
-
-yyreturn:
-  if (yychar != YYEMPTY)
-    {
-      /* Make sure we have latest lookahead translation.  See comments at
-         user semantic actions for why this is necessary.  */
-      yytoken = YYTRANSLATE (yychar);
-      yydestruct ("Cleanup: discarding lookahead",
-                  yytoken, &yylval);
-    }
-  /* Do not reclaim the symbols of the rule which action triggered
-     this YYABORT or YYACCEPT.  */
-  YYPOPSTACK (yylen);
-  YY_STACK_PRINT (yyss, yyssp);
-  while (yyssp != yyss)
-    {
-      yydestruct ("Cleanup: popping",
-		  yystos[*yyssp], yyvsp);
-      YYPOPSTACK (1);
-    }
-#ifndef yyoverflow
-  if (yyss != yyssa)
-    YYSTACK_FREE (yyss);
-#endif
-#if YYERROR_VERBOSE
-  if (yymsg != yymsgbuf)
-    YYSTACK_FREE (yymsg);
-#endif
-  /* Make sure YYID is used.  */
-  return YYID (yyresult);
-}
-
-
-
-/* Line 2067 of yacc.c  */
-#line 632 "core/pbrtparse.yy"
-
-static const char *paramTypeToName(int type) {
-    switch (type) {
-    case PARAM_TYPE_INT: return "int";
-    case PARAM_TYPE_BOOL: return "bool";
-    case PARAM_TYPE_FLOAT: return "float";
-    case PARAM_TYPE_POINT: return "point";
-    case PARAM_TYPE_VECTOR: return "vector";
-    case PARAM_TYPE_NORMAL: return "normal";
-    case PARAM_TYPE_RGB: return "rgb/color";
-    case PARAM_TYPE_XYZ: return "xyz";
-    case PARAM_TYPE_BLACKBODY: return "blackbody";
-    case PARAM_TYPE_SPECTRUM: return "spectrum";
-    case PARAM_TYPE_STRING: return "string";
-    case PARAM_TYPE_TEXTURE: return "texture";
-    default: Severe("Error in paramTypeToName"); return NULL;
-    }
-}
-
-
-static void InitParamSet(ParamSet &ps, SpectrumType type) {
-    ps.Clear();
-    for (uint32_t i = 0; i < cur_paramlist.size(); ++i) {
-        int type;
-        string name;
-        if (lookupType(cur_paramlist[i].name, &type, name)) {
-            if (type == PARAM_TYPE_TEXTURE || type == PARAM_TYPE_STRING ||
-                type == PARAM_TYPE_BOOL) {
-                if (!cur_paramlist[i].isString) {
-                    Error("Expected string parameter value for parameter \"%s\" with type \"%s\". Ignoring.",
-                          name.c_str(), paramTypeToName(type));
-                    continue;
-                }
-            }
-            else if (type != PARAM_TYPE_SPECTRUM) { /* spectrum can be either... */
-                if (cur_paramlist[i].isString) {
-                    Error("Expected numeric parameter value for parameter \"%s\" with type \"%s\".  Ignoring.",
-                          name.c_str(), paramTypeToName(type));
-                    continue;
-                }
-            }
-            void *data = cur_paramlist[i].arg;
-            int nItems = cur_paramlist[i].size;
-            if (type == PARAM_TYPE_INT) {
-                // parser doesn't handle ints, so convert from floats here....
-                int nAlloc = nItems;
-                int *idata = new int[nAlloc];
-                float *fdata = (float *)cur_paramlist[i].arg;
-                for (int j = 0; j < nAlloc; ++j)
-                    idata[j] = int(fdata[j]);
-                ps.AddInt(name, idata, nItems);
-                delete[] idata;
-            }
-            else if (type == PARAM_TYPE_BOOL) {
-                // strings -> bools
-                int nAlloc = cur_paramlist[i].size;
-                bool *bdata = new bool[nAlloc];
-                for (int j = 0; j < nAlloc; ++j) {
-                    string s(((const char **)data)[j]);
-                    if (s == "true") bdata[j] = true;
-                    else if (s == "false") bdata[j] = false;
-                    else {
-                        Warning("Value \"%s\" unknown for boolean parameter \"%s\"."
-                            "Using \"false\".", s.c_str(), cur_paramlist[i].name);
-                        bdata[j] = false;
-                    }
-                }
-                ps.AddBool(name, bdata, nItems);
-                delete[] bdata;
-            }
-            else if (type == PARAM_TYPE_FLOAT) {
-                ps.AddFloat(name, (float *)data, nItems);
-            } else if (type == PARAM_TYPE_POINT) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess values given with point parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddPoint(name, (Point *)data, nItems / 3);
-            } else if (type == PARAM_TYPE_VECTOR) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess values given with vector parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddVector(name, (Vector *)data, nItems / 3);
-            } else if (type == PARAM_TYPE_NORMAL) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess values given with normal parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddNormal(name, (Normal *)data, nItems / 3);
-            } else if (type == PARAM_TYPE_RGB) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess RGB values given with parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddRGBSpectrum(name, (float *)data, nItems);
-            } else if (type == PARAM_TYPE_XYZ) {
-                if ((nItems % 3) != 0)
-                    Warning("Excess XYZ values given with parameter \"%s\". "
-                            "Ignoring last %d of them", cur_paramlist[i].name, nItems % 3);
-                ps.AddXYZSpectrum(name, (float *)data, nItems);
-            } else if (type == PARAM_TYPE_BLACKBODY) {
-                if ((nItems % 2) != 0)
-                    Warning("Excess value given with blackbody parameter \"%s\". "
-                            "Ignoring extra one.", cur_paramlist[i].name);
-                ps.AddBlackbodySpectrum(name, (float *)data, nItems);
-            } else if (type == PARAM_TYPE_SPECTRUM) {
-                if (cur_paramlist[i].isString) {
-                    ps.AddSampledSpectrumFiles(name, (const char **)data, nItems);
-                }
-                else {
-                    if ((nItems % 2) != 0)
-                        Warning("Non-even number of values given with sampled spectrum "
-                                "parameter \"%s\". Ignoring extra.", cur_paramlist[i].name);
-                    ps.AddSampledSpectrum(name, (float *)data, nItems);
-                }
-            } else if (type == PARAM_TYPE_STRING) {
-                string *strings = new string[nItems];
-                for (int j = 0; j < nItems; ++j)
-                    strings[j] = string(((const char **)data)[j]);
-                ps.AddString(name, strings, nItems);
-                delete[] strings;
-            }
-            else if (type == PARAM_TYPE_TEXTURE) {
-                if (nItems == 1) {
-                    string val(*((const char **)data));
-                    ps.AddTexture(name, val);
-                }
-                else
-                    Error("Only one string allowed for \"texture\" parameter \"%s\"",
-                        name.c_str());
-            }
-        }
-        else
-            Warning("Type of parameter \"%s\" is unknown",
-                cur_paramlist[i].name);
-    }
-}
-
-
-static bool lookupType(const char *name, int *type, string &sname) {
-    Assert(name != NULL);
-    *type = 0;
-    const char *strp = name;
-    while (*strp && isspace(*strp))
-        ++strp;
-    if (!*strp) {
-        Error("Parameter \"%s\" doesn't have a type declaration?!", name);
-        return false;
-    }
-#define TRY_DECODING_TYPE(name, mask) \
-        if (strncmp(name, strp, strlen(name)) == 0) { \
-            *type = mask; strp += strlen(name); \
-        }
-         TRY_DECODING_TYPE("float",     PARAM_TYPE_FLOAT)
-    else TRY_DECODING_TYPE("integer",   PARAM_TYPE_INT)
-    else TRY_DECODING_TYPE("bool",      PARAM_TYPE_BOOL)
-    else TRY_DECODING_TYPE("point",     PARAM_TYPE_POINT)
-    else TRY_DECODING_TYPE("vector",    PARAM_TYPE_VECTOR)
-    else TRY_DECODING_TYPE("normal",    PARAM_TYPE_NORMAL)
-    else TRY_DECODING_TYPE("string",    PARAM_TYPE_STRING)
-    else TRY_DECODING_TYPE("texture",   PARAM_TYPE_TEXTURE)
-    else TRY_DECODING_TYPE("color",     PARAM_TYPE_RGB)
-    else TRY_DECODING_TYPE("rgb",       PARAM_TYPE_RGB)
-    else TRY_DECODING_TYPE("xyz",       PARAM_TYPE_XYZ)
-    else TRY_DECODING_TYPE("blackbody", PARAM_TYPE_BLACKBODY)
-    else TRY_DECODING_TYPE("spectrum",  PARAM_TYPE_SPECTRUM)
-    else {
-        Error("Unable to decode type for name \"%s\"", name);
-        return false;
-    }
-    while (*strp && isspace(*strp))
-        ++strp;
-    sname = string(strp);
-    return true;
-}
-
-
-
diff -uarN pbrt/core/pbrtparse.hh rendernet_pbrt/core/pbrtparse.hh
--- pbrt/core/pbrtparse.hh	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/pbrtparse.hh	1970-01-01 00:00:00.000000000 +0000
@@ -1,115 +0,0 @@
-/* A Bison parser, made by GNU Bison 2.5.1.  */
-
-/* Bison interface for Yacc-like parsers in C
-   
-      Copyright (C) 1984, 1989-1990, 2000-2012 Free Software Foundation, Inc.
-   
-   This program is free software: you can redistribute it and/or modify
-   it under the terms of the GNU General Public License as published by
-   the Free Software Foundation, either version 3 of the License, or
-   (at your option) any later version.
-   
-   This program is distributed in the hope that it will be useful,
-   but WITHOUT ANY WARRANTY; without even the implied warranty of
-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-   GNU General Public License for more details.
-   
-   You should have received a copy of the GNU General Public License
-   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
-
-/* As a special exception, you may create a larger work that contains
-   part or all of the Bison parser skeleton and distribute that work
-   under terms of your choice, so long as that work isn't itself a
-   parser generator using the skeleton or a modified version thereof
-   as a parser skeleton.  Alternatively, if you modify or redistribute
-   the parser skeleton itself, you may (at your option) remove this
-   special exception, which will cause the skeleton and the resulting
-   Bison output files to be licensed under the GNU General Public
-   License without this special exception.
-   
-   This special exception was added by the Free Software Foundation in
-   version 2.2 of Bison.  */
-
-
-/* Tokens.  */
-#ifndef YYTOKENTYPE
-# define YYTOKENTYPE
-   /* Put the tokens into the symbol table, so that GDB and other debuggers
-      know about them.  */
-   enum yytokentype {
-     STRING = 258,
-     ID = 259,
-     NUM = 260,
-     LBRACK = 261,
-     RBRACK = 262,
-     ACCELERATOR = 263,
-     ACTIVETRANSFORM = 264,
-     ALL = 265,
-     AREALIGHTSOURCE = 266,
-     ATTRIBUTEBEGIN = 267,
-     ATTRIBUTEEND = 268,
-     CAMERA = 269,
-     CONCATTRANSFORM = 270,
-     COORDINATESYSTEM = 271,
-     COORDSYSTRANSFORM = 272,
-     ENDTIME = 273,
-     FILM = 274,
-     IDENTITY = 275,
-     INCLUDE = 276,
-     LIGHTSOURCE = 277,
-     LOOKAT = 278,
-     MAKENAMEDMATERIAL = 279,
-     MATERIAL = 280,
-     NAMEDMATERIAL = 281,
-     OBJECTBEGIN = 282,
-     OBJECTEND = 283,
-     OBJECTINSTANCE = 284,
-     PIXELFILTER = 285,
-     RENDERER = 286,
-     REVERSEORIENTATION = 287,
-     ROTATE = 288,
-     SAMPLER = 289,
-     SCALE = 290,
-     SHAPE = 291,
-     STARTTIME = 292,
-     SURFACEINTEGRATOR = 293,
-     TEXTURE = 294,
-     TRANSFORMBEGIN = 295,
-     TRANSFORMEND = 296,
-     TRANSFORMTIMES = 297,
-     TRANSFORM = 298,
-     TRANSLATE = 299,
-     VOLUME = 300,
-     VOLUMEINTEGRATOR = 301,
-     WORLDBEGIN = 302,
-     WORLDEND = 303,
-     HIGH_PRECEDENCE = 304
-   };
-#endif
-
-
-
-#if ! defined YYSTYPE && ! defined YYSTYPE_IS_DECLARED
-typedef union YYSTYPE
-{
-
-/* Line 2136 of yacc.c  */
-#line 157 "build/darwin-debug/core/pbrtparse.yy"
-
-char string[1024];
-float num;
-ParamArray *ribarray;
-
-
-
-/* Line 2136 of yacc.c  */
-#line 107 "build/darwin-debug/core/pbrtparse.hh"
-} YYSTYPE;
-# define YYSTYPE_IS_TRIVIAL 1
-# define yystype YYSTYPE /* obsolescent; will be withdrawn */
-# define YYSTYPE_IS_DECLARED 1
-#endif
-
-extern YYSTYPE yylval;
-
-
diff -uarN pbrt/core/reflection.cpp rendernet_pbrt/core/reflection.cpp
--- pbrt/core/reflection.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/reflection.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -28,7 +28,7 @@
     OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
  */
-
+ 
 
 // core/reflection.cpp*
 #include "stdafx.h"
@@ -654,3 +654,11 @@
 }
 
 
+
+Spectrum BSDF::K() const {
+    Spectrum k(0.f);
+    for(int i = 0; i < nBxDFs; i++)
+        k += bxdfs[i]->K();
+    return k;
+}
+
diff -uarN pbrt/core/reflection.h rendernet_pbrt/core/reflection.h
--- pbrt/core/reflection.h	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/core/reflection.h	2019-09-07 01:14:54.000000000 +0000
@@ -177,6 +177,9 @@
     Spectrum rho(const Vector &wo, RNG &rng, BxDFType flags = BSDF_ALL,
                  int sqrtSamples = 6) const;
 
+    Spectrum K() const;
+    Normal N() const {return nn;}
+    
     // BSDF Public Data
     const DifferentialGeometry dgShading;
     const float eta;
@@ -214,6 +217,8 @@
                          const float *samples2) const;
     virtual float Pdf(const Vector &wi, const Vector &wo) const;
 
+    virtual Spectrum K() const = 0;
+
     // BxDF Public Data
     const BxDFType type;
 };
@@ -239,6 +244,11 @@
         return brdf->rho(nSamples, samples1, samples2);
     }
     float Pdf(const Vector &wo, const Vector &wi) const;
+
+    Spectrum K() const {
+        return brdf->K();
+    }
+
 private:
     BxDF *brdf;
 };
@@ -260,6 +270,10 @@
     Spectrum f(const Vector &wo, const Vector &wi) const;
     Spectrum Sample_f(const Vector &wo, Vector *wi,
         float u1, float u2, float *pdf) const;
+
+    Spectrum K() const {
+        return s*bxdf->K();
+    }
 private:
     BxDF *bxdf;
     Spectrum s;
@@ -318,6 +332,10 @@
     float Pdf(const Vector &wo, const Vector &wi) const {
         return 0.;
     }
+
+    Spectrum K() const {
+        return Spectrum();
+    }
 private:
     // SpecularReflection Private Data
     Spectrum R;
@@ -342,6 +360,10 @@
     float Pdf(const Vector &wo, const Vector &wi) const {
         return 0.;
     }
+
+    Spectrum K() const {
+        return Spectrum();
+    }
 private:
     // SpecularTransmission Private Data
     Spectrum T;
@@ -358,6 +380,10 @@
     Spectrum f(const Vector &wo, const Vector &wi) const;
     Spectrum rho(const Vector &, int, const float *) const { return R; }
     Spectrum rho(int, const float *, const float *) const { return R; }
+
+    Spectrum K() const {
+        return R;
+    }
 private:
     // Lambertian Private Data
     Spectrum R;
@@ -376,6 +402,10 @@
         A = 1.f - (sigma2 / (2.f * (sigma2 + 0.33f)));
         B = 0.45f * sigma2 / (sigma2 + 0.09f);
     }
+
+    Spectrum K() const {
+        return R;
+    }
 private:
     // OrenNayar Private Data
     Spectrum R;
@@ -411,6 +441,10 @@
     Spectrum Sample_f(const Vector &wo, Vector *wi,
                               float u1, float u2, float *pdf) const;
     float Pdf(const Vector &wo, const Vector &wi) const;
+
+    Spectrum K() const {
+        return R;
+    }
 private:
     // Microfacet Private Data
     Spectrum R;
@@ -470,6 +504,11 @@
     }
     Spectrum Sample_f(const Vector &wi, Vector *sampled_f, float u1, float u2, float *pdf) const;
     float Pdf(const Vector &wi, const Vector &wo) const;
+
+    Spectrum K() const {
+        return Rd;
+    }
+
 private:
     // FresnelBlend Private Data
     Spectrum Rd, Rs;
@@ -483,6 +522,11 @@
     IrregIsotropicBRDF(const KdTree<IrregIsotropicBRDFSample> *d)
         : BxDF(BxDFType(BSDF_REFLECTION | BSDF_GLOSSY)), isoBRDFData(d) { }
     Spectrum f(const Vector &wo, const Vector &wi) const;
+
+    Spectrum K() const {
+        return Spectrum();
+    }
+
 private:
     // IrregIsotropicBRDF Private Data
     const KdTree<IrregIsotropicBRDFSample> *isoBRDFData;
@@ -497,6 +541,11 @@
         : BxDF(BxDFType(BSDF_REFLECTION | BSDF_GLOSSY)), brdf(d),
           nThetaH(nth), nThetaD(ntd), nPhiD(npd) { }
     Spectrum f(const Vector &wo, const Vector &wi) const;
+
+    Spectrum K() const {
+        return Spectrum();
+    }
+
 private:
     // RegularHalfangleBRDF Private Data
     const float *brdf;
diff -uarN pbrt/core/samplerecord.cpp rendernet_pbrt/core/samplerecord.cpp
--- pbrt/core/samplerecord.cpp	1970-01-01 00:00:00.000000000 +0000
+++ rendernet_pbrt/core/samplerecord.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -0,0 +1,532 @@
+#include "samplerecord.h"
+#include "pbrt.h"
+#include <fstream>
+#include <iostream>
+#include <iterator>
+#include <lz4frame.h>
+
+int SampleRecord::version = 20190401;
+int SampleRecord::reference_images = 1;
+int SampleRecord::buffer_channels = 15;
+int SampleRecord::sample_features = 
+  5   // dx, dy, u, v, t
+  + 3*2 // rgb*(diffuse + specular)
+  + 3  // normals_at_first
+  + 3   // normals
+  + 1   // depth_at_first
+  + 1   // depth
+  + 1   // visibility
+  + 1   // hit
+  + 3   // albedo_at_first
+  + 3;  // albedo
+int SampleRecord::pixel_features = SampleRecord::buffer_channels*2*SampleRecord::reference_images; // 2: mean + variance
+
+RadianceQueryRecord::RadianceQueryRecord() {
+  count = 0;
+  buffer = std::vector<float>(SampleRecord::buffer_channels, 0.0f);
+  var_buffer = std::vector<float>(SampleRecord::buffer_channels, 0.0f);
+}
+
+RadianceQueryRecord::RadianceQueryRecord(
+      Spectrum radiance, Spectrum diffuse, Spectrum albedo, Normal nrm, 
+      float depth, bool visibility, bool hasHit) {
+  count = 1;
+  buffer = std::vector<float>(SampleRecord::buffer_channels, 0.0f);
+  var_buffer = std::vector<float>(SampleRecord::buffer_channels, 0.0f);
+
+  radiance = check_radiance(radiance);
+  diffuse = check_radiance(diffuse);
+  albedo = check_radiance(albedo);
+
+  float rgb_d[3];
+  diffuse.ToRGB(rgb_d);
+  float rgb_s[3];
+  Spectrum specular = radiance-diffuse;
+  specular.ToRGB(rgb_s);  // specular
+  float rgb_a[3];
+  albedo.ToRGB(rgb_a);
+
+  std::copy(rgb_d, rgb_d+3, buffer.begin());
+  std::copy(rgb_s, rgb_s+3, buffer.begin() + 3);
+  std::copy(rgb_a, rgb_a+3, buffer.begin() + 6);
+  buffer[9]  = nrm.x;
+  buffer[10] = nrm.y;
+  buffer[11] = nrm.z;
+  buffer[12] = depth;
+  buffer[13] = visibility ? 1.0f : 0.0f;
+  buffer[14] = hasHit ? 1.0f : 0.0f;
+}
+
+void RadianceQueryRecord::add(const RadianceQueryRecord &other, float rayWeight) {
+  if (rayWeight != 1.0f) {
+    Error("RayWeight should be 1.0. Not handled by sample saver");
+    throw;
+  }
+
+  count += 1;
+  for (int i = 0; i < (int)buffer.size(); ++i) {
+    float mean = buffer[i];
+    float delta = other.buffer[i] - mean;
+    mean += delta / count;
+    buffer[i] = mean;
+    float delta2 = other.buffer[i] - mean;
+    var_buffer[i] += delta*delta2;
+  }
+}
+
+Spectrum RadianceQueryRecord::check_radiance(Spectrum &r) {
+  if (r.HasNaNs()) {
+    Error("Not-a-number radiance value returned "
+        "for image sample.  Setting to black.");
+    return Spectrum(0.0f);
+  } else if (r.y() < 0) {
+    Error("Negative luminance value, %f, returned "
+        "for image sample.  Setting to black.", r.y());
+    return Spectrum(0.0f);
+  } else if (isinf(r.y())) {
+    Error("Infinite luminance value returned "
+        "for image sample.  Setting to black.");
+    return Spectrum(0.0f);
+  }
+  return r;
+}
+
+void LightQueryRecord::set_angles(Vector wi) {
+    // spherical coordinates of light direction
+    // in camera space
+    wi = world2cam(wi);
+
+    float nrm = sqrt(wi.x*wi.x + wi.y*wi.y);
+    
+    if(nrm == 0.0f) {
+      theta = 0.0f;
+    } else {
+      theta = atan2(wi.y, wi.x);
+    }
+
+    if (nrm == 0.0f && wi.z == 0) {
+      phi = 0.0f;
+    } else {
+      phi = atan2(nrm, wi.z);
+    }
+    theta /= M_PI;
+    phi /= M_PI;
+}
+
+SampleRecord::SampleRecord(
+    int x, int y, int tilesize, int sample_count, int spp, int maxDepth,
+    int image_width, int image_height, float scene_radius,
+    float focal_distance, float aperture_radius, float fov, bool useCameraSpaceNormals)
+  : tile_x(x), tile_y(y), tileSize(tilesize), sample_count(sample_count),
+  spp(spp), maxDepth(maxDepth+1),  // We store path 0...maxDepth
+  image_width(image_width), image_height(image_height),
+  scene_radius(scene_radius), focal_distance(focal_distance),
+  aperture_radius(aperture_radius), fov(fov),
+  useCameraSpaceNormals(useCameraSpaceNormals), is_kpcn(false)
+{
+  // prefix
+  pixel_x.reserve(tileSize*tileSize*sample_count);
+  pixel_y.reserve(tileSize*tileSize*sample_count);
+  subpixel_x.reserve(tileSize*tileSize*sample_count);
+  subpixel_y.reserve(tileSize*tileSize*sample_count);
+  lens_u.reserve(tileSize*tileSize*sample_count);
+  lens_v.reserve(tileSize*tileSize*sample_count);
+  time.reserve(tileSize*tileSize*sample_count);
+
+  // sample data
+  radiance_diffuse.reserve(tileSize*tileSize*sample_count);
+  // radiance_diffuse_indirect.reserve(tileSize*tileSize*sample_count);
+  radiance_specular.reserve(tileSize*tileSize*sample_count);
+  normal_at_first.reserve(tileSize*tileSize*sample_count);
+  depth_at_first.reserve(tileSize*tileSize*sample_count);
+  normal.reserve(tileSize*tileSize*sample_count);
+  depth.reserve(tileSize*tileSize*sample_count);
+  visibility.reserve(tileSize*tileSize*sample_count);
+  hasHit.reserve(tileSize*tileSize*sample_count);
+  albedo.reserve(tileSize*tileSize*sample_count);
+  albedo_at_first.reserve(tileSize*tileSize*sample_count);
+  probabilities.reserve(tileSize*tileSize*sample_count);
+  light_directions.reserve(tileSize*tileSize*sample_count);
+  bounce_type.reserve(tileSize*tileSize*sample_count);
+
+  // suffix
+  image_data.reserve(buffer_channels*2*SampleRecord::reference_images); // 2 reference images (+ variance)
+  for (int i = 0; i < SampleRecord::reference_images*2*buffer_channels; ++i) {
+    image_data.push_back(std::vector<float>());
+    image_data[i].reserve(tileSize*tileSize);
+  }
+}
+
+void SampleRecord::check_sizes() {
+  if ((int)pixel_x.size() != tileSize*tileSize*sample_count)
+    Error("incorrect pixel_x %d, shoudl be %d. %d %d",
+        pixel_x.size(), tileSize*tileSize*sample_count, 
+        tileSize, sample_count);
+  if ((int)pixel_y.size() != tileSize*tileSize*sample_count)
+    Error("incorrect pixel_y");
+  if ((int)subpixel_x.size() != tileSize*tileSize*sample_count)
+    Error("incorrect subpixel_x");
+  if ((int)subpixel_y.size() != tileSize*tileSize*sample_count)
+    Error("incorrect subpixel_y");
+  if ((int)lens_u.size() != tileSize*tileSize*sample_count)
+    Error("incorrect lens_u");
+  if ((int)lens_v.size() != tileSize*tileSize*sample_count)
+    Error("incorrect lens_v");
+  if ((int)time.size() != tileSize*tileSize*sample_count)
+    Error("incorrect time");
+
+  if ((int)radiance_diffuse.size() != tileSize*tileSize*sample_count)
+    Error("incorrect radiance_diffuse");
+  // if ((int)radiance_diffuse_indirect.size() != tileSize*tileSize*sample_count)
+  //   Error("incorrect radiance_diffuse_indirect");
+  if ((int)radiance_specular.size() != tileSize*tileSize*sample_count)
+    Error("incorrect radiance_specular");
+  if ((int)normal_at_first.size() != tileSize*tileSize*sample_count)
+    Error("incorrect normal_at_first (got %lu expected %d)",
+        normal_at_first.size(), tileSize*tileSize*sample_count);
+  if ((int)depth_at_first.size() != tileSize*tileSize*sample_count)
+    Error("incorrect depth  at first (got %lu expected %d)",
+        depth_at_first.size(), tileSize*tileSize*sample_count);
+  if ((int)normal.size() != tileSize*tileSize*sample_count)
+    Error("incorrect normal");
+  if ((int)depth.size() != tileSize*tileSize*sample_count)
+    Error("incorrect depth");
+  if ((int)visibility.size() != tileSize*tileSize*sample_count)
+    Error("incorrect visibility");
+  if ((int)hasHit.size() != tileSize*tileSize*sample_count)
+    Error("incorrect hasHit");
+  if ((int)albedo.size() != tileSize*tileSize*sample_count)
+    Error("incorrect albedo");
+  if ((int)albedo_at_first.size() != tileSize*tileSize*sample_count)
+    Error("incorrect albedo at first (got %lu expected %d)",
+        albedo_at_first.size(), tileSize*tileSize*sample_count);
+  if ((int)probabilities.size() != tileSize*tileSize*sample_count)
+    Error("incorrect probabilities at first (got %lu expected %d)",
+        probabilities.size(), tileSize*tileSize*sample_count);
+
+  for (int i = 0; i < buffer_channels ; ++i) {
+    if (image_data[i].size() != tileSize*tileSize)
+      Error("incorrect image data");
+  }
+}
+
+void SampleRecord::write_rgb_buffer(
+    vector<RGBSpectrum> &src, std::ostream &f, float clamp) {
+  int npixels = tileSize*tileSize;
+  float* tmp = new float[npixels*3];
+  float rgb[3] = {0};
+  // convert to contiguous pixels
+  for(int pixel_id = 0; pixel_id < npixels; ++pixel_id) {
+    src[pixel_id].ToRGB(rgb);
+    for(int i = 0; i < 3; ++i)  {
+      if(clamp > 0.0f) {
+        rgb[i] = min(rgb[i], clamp);
+      }
+      tmp[i*npixels + pixel_id] = rgb[i];
+    }
+  }
+
+  f.write((char*) tmp, 3*npixels*sizeof(float));
+  delete[] tmp;
+}
+
+void SampleRecord::write_sample_buffer(
+    int sample_id, vector<float> &src, std::ostream &f) {
+  int npixels = tileSize*tileSize;
+  float* tmp = new float[npixels];
+  // convert to contiguous pixels
+  for(int pixel_id = 0; pixel_id < npixels; ++pixel_id)
+  {
+    int src_idx = sample_id + sample_count*pixel_id;
+    int tgt_idx = pixel_id;
+    tmp[tgt_idx] = src[src_idx];
+  }
+
+  f.write((char*) tmp, npixels*sizeof(float));
+  delete[] tmp;
+}
+
+void SampleRecord::write_rgb_sample_buffer(
+    int sample_id, vector<RGBSpectrum> &src, std::ostream &f, float clamp) {
+  int npixels = tileSize*tileSize;
+  float* tmp = new float[npixels*3];
+  float rgb[3] = {0};
+  // convert to contiguous pixels
+  for(int pixel_id = 0; pixel_id < npixels; ++pixel_id)
+  {
+    int src_idx = sample_id + sample_count*pixel_id;
+    src[src_idx].ToRGB(rgb);
+    for(int i = 0; i < 3; ++i)  {
+      if(clamp > 0.0f) {
+        rgb[i] = min(rgb[i], clamp);
+      }
+      tmp[i*npixels + pixel_id] = rgb[i];
+    }
+  }
+
+  f.write((char*) tmp, 3*npixels*sizeof(float));
+  delete[] tmp;
+}
+
+void SampleRecord::write_normal_sample_buffer(
+    int sample_id, vector<Normal> &src, std::ostream &f) {
+  int npixels = tileSize*tileSize;
+  float* tmp = new float[npixels*3];
+  // convert to contiguous pixels
+  for(int pixel_id = 0; pixel_id < npixels; ++pixel_id)
+  {
+    int src_idx = sample_id + sample_count*pixel_id;
+    Normal n = src[src_idx];
+    tmp[0*npixels + pixel_id] = n.x;
+    tmp[1*npixels + pixel_id] = n.y;
+    tmp[2*npixels + pixel_id] = n.z;
+  }
+
+  f.write((char*) tmp, 3*npixels*sizeof(float));
+  delete[] tmp;
+}
+
+void SampleRecord::write_float_path_data
+(int sample_id, int count, vector<vector<float> > &src, std::ostream &f) {
+  int npixels = tileSize*tileSize;
+  int n_proba = count*maxDepth;
+  float* tmp = new float[npixels*n_proba];
+  // convert to contiguous pixels
+  for(int pixel_id = 0; pixel_id < npixels; ++pixel_id)
+  {
+    int src_idx = sample_id + sample_count*pixel_id;
+    vector<float> p = src[src_idx];
+    for(int i = 0; i < n_proba; ++ i) {
+      int tgt_idx = i*npixels + pixel_id;
+      tmp[tgt_idx] = p[i];
+    }
+  }
+
+  f.write((char*) tmp, n_proba*npixels*sizeof(float));
+  delete[] tmp;
+}
+
+void SampleRecord::write_bt_sample_buffer(
+    int sample_id, vector<vector<uint16_t> > &src, std::ostream &f) {
+  int npixels = tileSize*tileSize;
+  int n = maxDepth;
+  uint16_t* tmp = new uint16_t[npixels*n];
+  // convert to contiguous pixels
+  for(int pixel_id = 0; pixel_id < npixels; ++pixel_id)
+  {
+    int src_idx = sample_id + sample_count*pixel_id;
+    vector<uint16_t> p = src[src_idx];
+    for(int i = 0; i < n; ++ i) {
+      int tgt_idx = i*npixels + pixel_id;
+      tmp[tgt_idx] = p[i];
+    }
+  }
+
+  f.write((char*) tmp, n*npixels*sizeof(uint16_t));
+  delete[] tmp;
+}
+
+void SampleRecord::normalize_distances() {
+  int npixels = tileSize*tileSize;
+  float normalizer = scene_radius > 0.0f ? 1.0f/(10.0f*scene_radius) : 1.0f;
+  for(int i = 0; i < npixels*sample_count; ++i) {
+    depth[i] *= normalizer; 
+    depth_at_first[i] *= normalizer; 
+    lens_u[i] *= normalizer; 
+    lens_v[i] *= normalizer; 
+  }
+  focal_distance *= normalizer;
+  // If aperture is rescaled, u, v should be as well
+  aperture_radius *= normalizer;
+}
+
+void SampleRecord::normalize_probabilities() {
+  const int npixels = tileSize*tileSize;
+  const int n_proba = 4*maxDepth;
+  const float eps = 1e-8f;
+  const float nrm = 30.0f;
+  for(int i = 0; i < npixels*sample_count; ++i)
+  for(int j = 0; j < n_proba; ++j) {
+    float p = probabilities[i][j];
+    probabilities[i][j] = log(max(p, 0.0f) + eps) / nrm;
+  }
+}
+
+int SampleRecord::write_compressed(std::stringstream &fi, std::ostream &f) {
+  int compsize = LZ4F_compressFrameBound(fi.tellp(), NULL);
+  if(compsize == 0) {
+    throw "could not compress";
+  }
+  const std::string tmp = fi.str();
+  const char* cstr = tmp.c_str();
+  char *dst = new char[compsize];
+
+  int nbytes = LZ4F_compressFrame(dst, compsize, cstr, fi.tellp(), NULL);
+  if(nbytes == 0) {
+    throw "could not compress";
+  }
+
+  f.write((char*)&nbytes, sizeof(int));
+  f.write(dst, nbytes);
+  delete[] dst;
+
+  return nbytes;
+}
+
+void SampleRecord::add_image_sample(const RadianceQueryRecord &r, int sampler_idx) {
+  // TODO: normalize normals to be unit vectors...
+  for (int i = 0; i < buffer_channels; ++i) {
+    image_data[sampler_idx*buffer_channels*2 + i].push_back(r.buffer[i]);
+    float var = 0.f;
+    if (r.count > 1) {
+      var = r.var_buffer[i] / (r.count-1);
+    }
+
+    // Monte-Carlo variance estimate: 1/n * var
+    if (r.count > 0) {
+      var /= r.count;
+    }
+
+    image_data[sampler_idx*buffer_channels*2 + i + buffer_channels].push_back(var);
+  }
+}
+
+bool SampleRecord::has_nans() {
+  for(int s = 0; s < tileSize*tileSize*sample_count; ++s) {
+    if ( isnan(pixel_x[s]) )
+      return true;
+    if ( isnan(pixel_y[s]) )
+      return true;
+    if ( isnan(lens_u[s]) )
+      return true;
+    if ( isnan(lens_v[s]) )
+      return true;
+    if ( isnan(time[s]) )
+      return true;
+    if ( radiance_diffuse[s].HasNaNs() )
+      return true;
+    // if ( radiance_diffuse_indirect[s].HasNaNs() )
+    //   return true;
+    if ( radiance_specular[s].HasNaNs() )
+      return true;
+    if ( isnan(normal[s].x) || isnan(normal[s].y) || isnan(normal[s].z))
+      return true;
+    if (isnan(normal_at_first[s].x) || isnan(normal_at_first[s].y) ||
+        isnan(normal_at_first[s].z))
+      return true;
+    if ( isnan(depth[s]) )
+      return true;
+    if ( isnan(depth_at_first[s]) )
+      return true;
+    if ( isnan(visibility[s]) )
+      return true;
+    if ( isnan(hasHit[s]) )
+      return true;
+    if ( albedo[s].HasNaNs() )
+      return true;
+    if ( albedo_at_first[s].HasNaNs() )
+      return true;
+    for(int pidx=0; pidx < 4*maxDepth; ++pidx) {
+      if ( isnan(probabilities[s][pidx]) )
+        return true;
+    }
+    for(int pidx=0; pidx < 2*maxDepth; ++pidx) {
+      if ( isnan(light_directions[s][pidx]) )
+        return true;
+    }
+  }
+  for(int p = 0; p < tileSize*tileSize; ++p) {
+    for (int i = 0; i < buffer_channels ; ++i) {
+      if ( isnan(image_data[i][p]) )
+        return true;
+    }
+  }
+  return false;
+}
+
+void SampleRecord::save(const char* fname) {
+  check_sizes();
+  if (has_nans() ){
+    Error("NaNs in sample record, skipping save.");
+    return;
+  }
+
+  std::ofstream f(fname, std::ios::binary);
+
+  // Keep distances unnormalized for NFOR and KPCN
+  if(!is_kpcn) {
+    normalize_distances();
+    normalize_probabilities();
+  }
+
+  if (sample_count <= 0) {
+    Error("saved samples should be higher than 0, got %d.",
+        spp, sample_count);
+    return;
+  }
+
+  // Write metadata header
+  {
+    f.write((char*)&version, sizeof(int));
+    f.write((char*)&tileSize, sizeof(int));
+    f.write((char*)&image_width, sizeof(int));
+    f.write((char*)&image_height, sizeof(int));
+    f.write((char*)&sample_count, sizeof(int));
+    f.write((char*)&spp, sizeof(int));
+    f.write((char*)&sample_features, sizeof(int));
+    f.write((char*)&pixel_features, sizeof(int));
+    f.write((char*)&maxDepth, sizeof(int));
+  }
+
+  // Write globals
+  {
+    f.write((char*)&focal_distance, sizeof(float));
+    f.write((char*)&aperture_radius, sizeof(float));
+    float norm_fov = fov / 100.0f;
+    f.write((char*)&norm_fov, sizeof(float));
+    f.write((char*)&scene_radius, sizeof(float));
+  }
+  
+  // Write tile coordinates 
+  {
+    f.write((char*)&tile_x, sizeof(int));
+    f.write((char*)&tile_y, sizeof(int));
+  }
+
+  {
+    // Write pixel data
+    std::stringstream sstream;
+    std::ostream_iterator<float> it(sstream);
+    for (int i = 0; i < (int)image_data.size(); ++i) {
+      sstream.write((char*)image_data[i].data(), tileSize*tileSize*sizeof(float));
+    }
+    int nb = write_compressed(sstream, f);
+  }
+
+  // Write sample data
+  for(int sample_id = 0; sample_id < sample_count; ++sample_id) {
+    std::stringstream sstream;
+    write_sample_buffer(sample_id, subpixel_x, sstream);
+    write_sample_buffer(sample_id, subpixel_y, sstream);
+    write_sample_buffer(sample_id, lens_u, sstream);
+    write_sample_buffer(sample_id, lens_v, sstream);
+    write_sample_buffer(sample_id, time, sstream);
+    write_rgb_sample_buffer(sample_id, radiance_diffuse, sstream);
+    write_rgb_sample_buffer(sample_id, radiance_specular, sstream);
+    write_normal_sample_buffer(sample_id, normal_at_first, sstream);
+    write_normal_sample_buffer(sample_id, normal, sstream);
+    write_sample_buffer(sample_id, depth_at_first, sstream);
+    write_sample_buffer(sample_id, depth, sstream);
+    write_sample_buffer(sample_id, visibility, sstream);
+    write_sample_buffer(sample_id, hasHit, sstream);
+    write_rgb_sample_buffer(sample_id, albedo_at_first, sstream);
+    write_rgb_sample_buffer(sample_id, albedo, sstream);
+    write_float_path_data(sample_id, 4, probabilities, sstream);
+    write_float_path_data(sample_id, 2, light_directions, sstream);
+    write_bt_sample_buffer(sample_id, bounce_type, sstream);
+
+    write_compressed(sstream, f);
+  }
+  
+  f.close();
+}
diff -uarN pbrt/core/samplerecord.h rendernet_pbrt/core/samplerecord.h
--- pbrt/core/samplerecord.h	1970-01-01 00:00:00.000000000 +0000
+++ rendernet_pbrt/core/samplerecord.h	2019-09-07 01:14:54.000000000 +0000
@@ -0,0 +1,156 @@
+#ifndef SAMPLERECORD_H_WVTEISKD
+#define SAMPLERECORD_H_WVTEISKD
+
+#include "pbrt.h"
+#include "core/spectrum.h"
+#include "core/diffgeom.h"
+#include "core/transform.h"
+#include <vector>
+#include <sstream>
+
+using std::vector;
+
+/*! \enum FeatureType
+ *
+ *  Detailed description
+ */
+enum FeatureType {
+  DX = 0,
+  DY = 1,
+  LENS_U = 2,
+  LENS_V = 3,
+  T = 4,
+
+  RADIANCE = 5,
+  DIFFUSE = 5,
+  SPECULAR = 5,
+  ALBEDO = 5,
+
+  NORMAL = 5,
+  DEPTH = 5,
+  VISIBILITY = 5,
+
+};
+
+class RadianceQueryRecord {
+public:
+  RadianceQueryRecord();
+  RadianceQueryRecord(
+      Spectrum radiance, Spectrum diffuse, Spectrum albedo, Normal nrm, 
+      float depth, bool visibility, bool hasHit);
+
+  void add(const RadianceQueryRecord &other, float rayWeight);
+  Spectrum check_radiance(Spectrum &r);
+  int count;
+
+  std::vector<float> buffer;
+  std::vector<float> var_buffer;
+};
+
+class LightQueryRecord {
+
+public:
+  LightQueryRecord(Transform t) 
+    : isLightVisible(false), diffuse_lighting(0.0f), world2cam(t), theta(0.f), phi(0.f)
+  { memset(pdfs, 0, sizeof(float)*4); };
+  // Spectrum visibility;
+  bool isLightVisible;
+  Spectrum diffuse_lighting;
+  Transform world2cam;
+
+  // Spherical coordinates of light_sample
+  float theta;
+  float phi;
+  // Direct/BSDF light sampling pdf
+  float pdfs[4]; // (light_pdf, bsdf_pdf)_light, (light_pdf, bsdf_pdf)_bsdf
+
+  void set_angles(Vector wi);
+};
+
+class SampleRecord {
+public:
+  static int version;
+  static int sample_features;
+  static int pixel_features;
+  static int buffer_channels;
+  static int reference_images;
+
+  SampleRecord(
+      int x, int y, int tilesize, int sample_count, int spp, int maxDepth,
+      int image_width, int image_height, float scene_radius,
+      float focal_distance, float aperture_radius, float fov,
+      bool useCameraSpaceNormals);
+  void save(const char* fname);
+  void set_kpcn() { is_kpcn = true; };
+  void add_image_sample(const RadianceQueryRecord &r, int sampler_idx);
+
+  int tile_x;
+  int tile_y;
+  int tileSize;
+  int sample_count;
+  int spp;
+  int maxDepth;
+
+  int image_width;
+  int image_height;
+  float scene_radius;
+  float focal_distance;
+  float aperture_radius;
+  float fov;
+
+  bool useCameraSpaceNormals;
+
+  // prefix
+  vector<float> pixel_x;
+  vector<float> pixel_y;
+  vector<float> subpixel_x;
+  vector<float> subpixel_y;
+  vector<float> lens_u;
+  vector<float> lens_v;
+  vector<float> time;
+
+  // data
+  vector<RGBSpectrum> radiance_diffuse;
+  // vector<RGBSpectrum> radiance_diffuse_indirect;
+  vector<RGBSpectrum> radiance_specular;
+  vector<Normal> normal_at_first;
+  vector<float> depth_at_first;
+  vector<Normal> normal;
+  vector<float> depth;
+  vector<float> visibility;
+  vector<float> hasHit;
+  vector<RGBSpectrum> albedo;
+  vector<RGBSpectrum> albedo_at_first;
+  vector<vector<float> > probabilities;
+  vector<vector<float> > light_directions;
+  vector<vector<uint16_t> > bounce_type;  // see core/reflection.h
+
+  // suffix
+  // vector<RGBSpectrum> ground_truth;
+  // vector<RGBSpectrum> ground_truth_diffuse;
+  // vector<RGBSpectrum> ground_truth_variance;
+
+  vector<vector<float> > image_data;
+  
+
+private:
+  bool is_kpcn;
+  void check_sizes();
+  bool has_nans();
+
+  void normalize_distances();
+  void normalize_probabilities();
+
+  void write_rgb_buffer(vector<RGBSpectrum> &src, std::ostream &f, float clamp = -1.0f);
+
+  int write_compressed(std::stringstream &fi, std::ostream &f);
+
+  void write_sample_buffer(int sidx, vector<float> &src, std::ostream &f);
+  void write_rgb_sample_buffer(int sidx, vector<RGBSpectrum> &src, std::ostream &f, float clamp = -1.0f);
+  void write_normal_sample_buffer(int sidx, vector<Normal> &src, std::ostream &f);
+  void write_float_path_data(int sidx, int count, vector<vector<float> > &src, std::ostream &f);
+  void write_bt_sample_buffer(int sidx, vector<vector<uint16_t> > &src, std::ostream &f);
+
+};
+
+#endif /* end of include guard: SAMPLERECORD_H_WVTEISKD */
diff -uarN pbrt/integrators/pathkpcn.cpp rendernet_pbrt/integrators/pathkpcn.cpp
--- pbrt/integrators/pathkpcn.cpp	1970-01-01 00:00:00.000000000 +0000
+++ rendernet_pbrt/integrators/pathkpcn.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -0,0 +1,265 @@
+// integrators/pathkpcn.cpp*
+#include "stdafx.h"
+#include "integrators/pathkpcn.h"
+#include "core/camera.h"
+#include "scene.h"
+#include "intersection.h"
+#include "paramset.h"
+
+// PathKPCNIntegrator Method Definitions
+void PathKPCNIntegrator::RequestSamples(Sampler *sampler, Sample *sample,
+                                    const Scene *scene) {
+    for (int i = 0; i < SAMPLE_DEPTH; ++i) {
+        lightSampleOffsets[i] = LightSampleOffsets(1, sample);
+        lightNumOffset[i] = sample->Add1D(1);
+        bsdfSampleOffsets[i] = BSDFSampleOffsets(1, sample);
+        pathSampleOffsets[i] = BSDFSampleOffsets(1, sample);
+    }
+}
+
+Spectrum PathKPCNIntegrator::Li(const Scene *scene, const Renderer *renderer,
+        const RayDifferential &r, const Intersection &isect,
+        const Sample *sample, RNG &rng, MemoryArena &arena) const {
+  // return RecordedLi(scene, renderer, r, isect, sample, rng, arena, NULL, NULL);
+  throw;
+  return Spectrum(0.0f);
+}
+
+
+RadianceQueryRecord PathKPCNIntegrator::RecordedLi(const Scene *scene, const Renderer *renderer,
+        const RayDifferential &r, const Intersection &isect,
+        const Sample *sample, RNG &rng, MemoryArena &arena, SampleRecord *sr, Camera* camera) const {
+    // Declare common path integration variables
+    Spectrum pathThroughput = 1., L = 0.;
+    Spectrum pathThroughputDiffuse = 1., Ldiffuse = 0.;
+    RayDifferential ray(r);
+    bool specularBounce = true;
+    bool foundNonSpecular = false;
+    bool foundRough = false;
+    Intersection localIsect;
+    const Intersection *isectp = &isect;
+
+    // Default values
+    bool isLightVisible = false;
+    bool recordedOutputValues = false;
+    float hitDistance = 0.0f;
+    Normal nrm;
+    Normal nrm_at_first;
+    float depth = 0.0f;
+    float depth_at_first = 0.0f;
+    // float depth_at_first = -1.0f;
+    Spectrum albedo = 0.0f;
+    Spectrum albedo_at_first = 0.f;
+
+    for (int bounces = 0; ; ++bounces) {
+        // Possibly add emitted light at path vertex
+        // NOTE: tungsten samples this at all bounces
+        if (bounces == 0 || specularBounce) {
+          Spectrum contrib = isectp->Le(-ray.d);
+          L += contrib*pathThroughput;
+          if (foundRough) {
+            Ldiffuse += contrib*pathThroughputDiffuse;
+          }
+        }
+
+        BSDF *bsdf = isectp->GetBSDF(ray, arena);
+        const Point &p = bsdf->dgShading.p;
+        const Normal &n = bsdf->dgShading.nn;
+
+        bool bsdf_has_diffuse = false;
+        bsdf_has_diffuse =
+            (bsdf->NumComponents(BxDFType(BSDF_DIFFUSE|BSDF_REFLECTION)) > 0);
+        bool bsdf_has_nonspecular = false;
+        bsdf_has_nonspecular = bsdf_has_diffuse ||
+            (bsdf->NumComponents(BxDFType(BSDF_GLOSSY|BSDF_REFLECTION)) > 0) ||
+            (bsdf->NumComponents(BxDFType(BSDF_GLOSSY|BSDF_TRANSMISSION)) > 0);
+
+        Vector depth_vector = p-ray.o;
+        hitDistance += depth_vector.Length();
+
+        // Sample illumination from lights to find path contribution
+        Vector wo = -ray.d;
+        Spectrum contrib(0.0f);
+        Spectrum diffuse_lighting(0.0f);
+        Transform tx;
+        camera->CameraToWorld.Interpolate(sample->time, &tx);
+        tx = Inverse(tx);
+        LightQueryRecord qr(tx);
+        if (bounces < SAMPLE_DEPTH) {
+            contrib = UniformSampleOneLight(scene, renderer, arena, p, n, wo,
+                     isectp->rayEpsilon, ray.time, bsdf, sample, rng,
+                     lightNumOffset[bounces], &lightSampleOffsets[bounces],
+                     &bsdfSampleOffsets[bounces], &qr);
+        } else {
+            contrib = UniformSampleOneLight(scene, renderer, arena, p, n, wo,
+                     isectp->rayEpsilon, ray.time, bsdf, sample, rng, 
+                     -1, NULL, NULL, &qr);
+        }
+
+        L += contrib*pathThroughput;
+        if (!foundRough && bsdf_has_diffuse) {
+          Ldiffuse += qr.diffuse_lighting*pathThroughputDiffuse;
+        } else {
+          if (foundRough) {
+            Ldiffuse += contrib*pathThroughputDiffuse;
+          }
+        }
+        
+        // Sample BSDF to get new path direction
+
+        // Get _outgoingBSDFSample_ for sampling new path direction
+        BSDFSample outgoingBSDFSample;
+        if (bounces < SAMPLE_DEPTH)
+            outgoingBSDFSample = BSDFSample(sample, pathSampleOffsets[bounces],
+                                            0);
+        else
+            outgoingBSDFSample = BSDFSample(rng);
+        Vector wi;
+        float pdf;
+        BxDFType flags;
+        Spectrum f = bsdf->Sample_f(wo, &wi, outgoingBSDFSample, &pdf,
+                                    BSDF_ALL, &flags);
+        Spectrum currAlbedo = bsdf->K();
+        
+        // If the brdf has a diffuse component, we found our first
+        // diffuse interaction. The path is no longer purely specular.
+        bool isFirstRough = false;
+        if (!foundRough && bsdf_has_diffuse) {
+          foundRough = true;
+          isFirstRough = true;
+        } 
+
+        bool isFirstNonSpecular = false;
+        if (!foundNonSpecular && bsdf_has_nonspecular) {
+          foundNonSpecular = true;
+          isFirstNonSpecular = true;
+        } 
+        
+        // Save depth, normal, albedo at first non-specular
+        if (isFirstNonSpecular) {
+          Normal ssn(n);
+          if (Dot(ssn, ray.d) < 0) { //face forward
+            ssn.x *= -1.0f;
+            ssn.y *= -1.0f;
+            ssn.z *= -1.0f;
+          }
+          if(sr && sr->useCameraSpaceNormals) {
+            Transform tx;
+            camera->CameraToWorld.Interpolate(sample->time, &tx);
+            nrm_at_first = Inverse(tx)(ssn);
+          } else {
+            nrm_at_first = ssn;
+          }
+          depth_at_first = hitDistance;
+          albedo_at_first = currAlbedo;
+        }
+        
+        // record value at first rough 
+        if (sr && !recordedOutputValues && foundRough) {
+          recordedOutputValues = true;
+          depth = hitDistance;
+          albedo = currAlbedo;
+          isLightVisible = qr.isLightVisible;
+          Normal ssn(n);
+          if (Dot(ssn, ray.d) < 0) { //face forward
+            ssn.x *= -1.0f;
+            ssn.y *= -1.0f;
+            ssn.z *= -1.0f;
+          }
+
+          if(sr && sr->useCameraSpaceNormals) {
+            Transform tx;
+            camera->CameraToWorld.Interpolate(sample->time, &tx);
+            nrm = Inverse(tx)(ssn);
+          } else {
+            nrm = ssn;
+          }
+        } 
+
+
+        if (f.IsBlack() || pdf == 0.) {
+          break;
+        } 
+
+        Spectrum bsdfWeight =  f * AbsDot(wi, n) / pdf;
+        pathThroughput *= bsdfWeight;
+
+        specularBounce = (flags & BSDF_SPECULAR) != 0;
+
+        if (bsdfWeight.HasNaNs() || isinf(bsdfWeight.y())) {
+          Error("Not-a-number in bsdfweight");
+        }
+
+        if(isFirstRough) {
+          Spectrum bsdfWeightDiffuse = specularBounce ? Spectrum(0.0f) : 
+            bsdf->f(wo, wi, BxDFType(BSDF_DIFFUSE|BSDF_REFLECTION|BSDF_GLOSSY)) * AbsDot(wi, n) / pdf;
+          pathThroughputDiffuse *= bsdfWeightDiffuse;
+        } else {
+          pathThroughputDiffuse *= bsdfWeight;
+        }
+
+        // Scatter
+        ray = RayDifferential(p, wi, ray, isectp->rayEpsilon);
+
+        // Possibly terminate the path (russian roulette)
+        if (bounces > 3) {
+            float continueProbability = min(.5f, pathThroughput.y());
+            if (rng.RandomFloat() > continueProbability)
+                break;
+            pathThroughput /= continueProbability;
+        }
+        if (bounces == maxDepth_)
+            break;
+
+        // Find next vertex of path
+        if (!scene->Intersect(ray, &localIsect)) {
+            if (specularBounce) {
+                for (uint32_t i = 0; i < scene->lights.size(); ++i) {
+                  Spectrum contrib = scene->lights[i]->Le(ray);
+                  L += contrib*pathThroughput;
+                  if (foundRough) {
+                    Ldiffuse += contrib*pathThroughputDiffuse;
+                  }
+                }
+            }
+            break;
+        }
+        Spectrum transmittance = renderer->Transmittance(scene, ray, NULL, rng, arena);
+        pathThroughput *= transmittance;
+        pathThroughputDiffuse *= transmittance;
+        isectp = &localIsect;
+    }  // bounces loop
+
+    if (sr) {
+      sr->normal_at_first.push_back(nrm_at_first);
+      sr->normal.push_back(nrm);
+      sr->depth_at_first.push_back(depth_at_first);
+      sr->depth.push_back(depth);
+      sr->visibility.push_back(isLightVisible ? 1.0 : 0.0);
+      sr->hasHit.push_back(1.0);
+      sr->albedo.push_back(albedo);
+      sr->albedo_at_first.push_back(albedo_at_first);
+
+      sr->radiance_diffuse.push_back(Ldiffuse);
+      // sr->radiance_diffuse_indirect.push_back(Spectrum(0.0f));
+      sr->radiance_specular.push_back(L-Ldiffuse);
+
+      // Fill our features with dummies
+      std::vector<float> probabilities(4*(maxDepth_+1), 0.0f);
+      std::vector<float> light_directions(2*(maxDepth_+1), 0.0f);
+      std::vector<uint16_t> bounce_type((maxDepth_+1), 0);
+      sr->probabilities.push_back(probabilities);
+      sr->light_directions.push_back(light_directions);
+      sr->bounce_type.push_back(bounce_type);
+    }
+
+    // return RadianceQueryRecord(L, Ldiffuse);
+    return RadianceQueryRecord();
+}
+
+
+PathKPCNIntegrator *CreatePathKPCNSurfaceIntegrator(const ParamSet &params) {
+    int maxDepth = params.FindOneInt("maxdepth", 5);
+    printf("Max depth %d\n", maxDepth);
+    return new PathKPCNIntegrator(maxDepth);
+}
diff -uarN pbrt/integrators/pathkpcn.h rendernet_pbrt/integrators/pathkpcn.h
--- pbrt/integrators/pathkpcn.h	1970-01-01 00:00:00.000000000 +0000
+++ rendernet_pbrt/integrators/pathkpcn.h	2019-09-07 01:14:54.000000000 +0000
@@ -0,0 +1,40 @@
+#if defined(_MSC_VER)
+#pragma once
+#endif
+
+#ifndef PBRT_INTEGRATORS_PATH_KPCN_H
+#define PBRT_INTEGRATORS_PATH_KPCN_H
+
+// integrators/pathkpcn.h*
+#include "pbrt.h"
+#include "integrator.h"
+
+// PathKPCNIntegrator Declarations
+class PathKPCNIntegrator : public SurfaceIntegrator {
+public:
+    // PathKPCNIntegrator Public Methods
+    Spectrum Li(const Scene *scene, const Renderer *renderer,
+        const RayDifferential &ray, const Intersection &isect,
+        const Sample *sample, RNG &rng, MemoryArena &arena) const;
+    RadianceQueryRecord RecordedLi(const Scene *scene, const Renderer *renderer,
+        const RayDifferential &ray, const Intersection &isect,
+        const Sample *sample, RNG &rng, MemoryArena &arena, SampleRecord *sw, Camera *camera) const;
+    void RequestSamples(Sampler *sampler, Sample *sample, const Scene *scene);
+    PathKPCNIntegrator(int md) { maxDepth_ = md; }
+
+    virtual int maxDepth() {return maxDepth_;};
+
+private:
+    int maxDepth_;
+    // PathKPCNIntegrator Private Data
+#define SAMPLE_DEPTH 3
+    LightSampleOffsets lightSampleOffsets[SAMPLE_DEPTH];
+    int lightNumOffset[SAMPLE_DEPTH];
+    BSDFSampleOffsets bsdfSampleOffsets[SAMPLE_DEPTH];
+    BSDFSampleOffsets pathSampleOffsets[SAMPLE_DEPTH];
+};
+
+
+PathKPCNIntegrator *CreatePathKPCNSurfaceIntegrator(const ParamSet &params);
+
+#endif // PBRT_INTEGRATORS_PATH_KPCN_H
diff -uarN pbrt/integrators/pathrendernet.cpp rendernet_pbrt/integrators/pathrendernet.cpp
--- pbrt/integrators/pathrendernet.cpp	1970-01-01 00:00:00.000000000 +0000
+++ rendernet_pbrt/integrators/pathrendernet.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -0,0 +1,309 @@
+// integrators/pathrendernet.cpp*
+#include "stdafx.h"
+#include "integrators/pathrendernet.h"
+#include "core/camera.h"
+#include "scene.h"
+#include "intersection.h"
+#include "paramset.h"
+#include "core/samplerecord.h"
+
+// PathRendernetIntegrator Method Definitions
+void PathRendernetIntegrator::RequestSamples(Sampler *sampler, Sample *sample,
+                                    const Scene *scene) {
+    for (int i = 0; i < SAMPLE_DEPTH; ++i) {
+        lightSampleOffsets[i] = LightSampleOffsets(1, sample);
+        lightNumOffset[i] = sample->Add1D(1);
+        bsdfSampleOffsets[i] = BSDFSampleOffsets(1, sample);
+        pathSampleOffsets[i] = BSDFSampleOffsets(1, sample);
+    }
+}
+
+Spectrum PathRendernetIntegrator::Li(const Scene *scene, const Renderer *renderer,
+        const RayDifferential &r, const Intersection &isect,
+        const Sample *sample, RNG &rng, MemoryArena &arena) const {
+  // return RecordedLi(scene, renderer, r, isect, sample, rng, arena, NULL, NULL).L;
+  throw;
+  return Spectrum(0.0f); // TODO: fixme
+}
+
+RadianceQueryRecord PathRendernetIntegrator::RecordedLi(const Scene *scene, const Renderer *renderer,
+        const RayDifferential &r, const Intersection &isect,
+        const Sample *sample, RNG &rng, MemoryArena &arena, SampleRecord *sr, Camera* camera) const {
+    // Declare common path integration variables
+    Spectrum pathThroughput = 1., L = 0.;
+    Spectrum pathThroughputDiffuse = 1., Ldiffuse = 0. ;
+      // , Ldiffuse_indirect = 0.;
+    RayDifferential ray(r);
+    bool specularBounce = false;
+    bool foundRough = false;
+    bool foundNonSpecular = false;
+    Intersection localIsect;
+    const Intersection *isectp = &isect;
+
+    // Default values
+    bool isLightVisible = false;
+    bool recordedOutputValues = false;
+    float hitDistance = 0.0f;
+    Normal nrm;
+    Normal nrm_at_first;
+    float depth = 0.0f;
+    float depth_at_first = 0.0f;
+    Spectrum albedo = 0.f;
+    Spectrum albedo_at_first = 0.f;
+
+    std::vector<float> probabilities(4*(maxDepth_+1), 0.0f);
+    std::vector<float> light_directions(2*(maxDepth_+1), 0.0f);
+    std::vector<uint16_t> bounce_type((maxDepth_+1), 0);
+
+    for (int bounces = 0; ; ++bounces) {
+        // Possibly add emitted light at path vertex
+        if (bounces == 0 || specularBounce) {
+          Spectrum contrib = isectp->Le(-ray.d);
+          L += contrib*pathThroughput;
+          if (foundRough) {
+            Ldiffuse += contrib*pathThroughputDiffuse;
+            // if (bounces > 0)  {
+            //   Ldiffuse_indirect += contrib*pathThroughputDiffuse;
+            // }
+          }
+        }
+
+        BSDF *bsdf = isectp->GetBSDF(ray, arena);
+        const Point &p = bsdf->dgShading.p;
+        const Normal &n = bsdf->dgShading.nn;
+
+        // Characterize the brdf
+        bool bsdf_has_diffuse =
+            (bsdf->NumComponents(BxDFType(BSDF_DIFFUSE|BSDF_REFLECTION)) > 0);
+        bool bsdf_has_nonspecular = bsdf_has_diffuse ||
+            (bsdf->NumComponents(BxDFType(BSDF_GLOSSY|BSDF_REFLECTION)) > 0) ||
+            (bsdf->NumComponents(BxDFType(BSDF_GLOSSY|BSDF_TRANSMISSION)) > 0);
+
+        // Accumulate path length
+        Vector depth_vector = p-ray.o;
+        hitDistance += depth_vector.Length();
+
+        // Sample illumination from lights to find path contribution
+        Vector wo = -ray.d;
+        Spectrum contrib(0.0f);
+        Spectrum diffuse_lighting(0.0f);
+        Transform tx;
+        camera->CameraToWorld.Interpolate(sample->time, &tx);
+        tx = Inverse(tx);
+        LightQueryRecord qr(tx);
+        if (bounces < SAMPLE_DEPTH) {
+            contrib = UniformSampleOneLight(scene, renderer, arena, p, n, wo,
+                     isectp->rayEpsilon, ray.time, bsdf, sample, rng,
+                     lightNumOffset[bounces], &lightSampleOffsets[bounces],
+                     &bsdfSampleOffsets[bounces], &qr);
+        } else {
+            contrib = UniformSampleOneLight(scene, renderer, arena, p, n, wo,
+                     isectp->rayEpsilon, ray.time, bsdf, sample, rng, 
+                     -1, NULL, NULL, &qr);
+        }
+        
+        L += contrib*pathThroughput;
+        if (!foundRough && bsdf_has_diffuse) {
+          Ldiffuse += qr.diffuse_lighting*pathThroughputDiffuse;
+          // if (bounces > 0)  {
+          //   Ldiffuse_indirect += qr.diffuse_lighting*pathThroughputDiffuse;
+          // }
+        } else if (foundRough) {
+          Ldiffuse += contrib*pathThroughputDiffuse;
+          // if (bounces > 0)  {
+          //   Ldiffuse_indirect += contrib*pathThroughputDiffuse;
+          // }
+        }
+
+        // Store the lighting directions
+        std::copy(qr.pdfs, qr.pdfs+4, probabilities.begin()+4*bounces);
+        light_directions[2*bounces + 0] = qr.theta;
+        light_directions[2*bounces + 1] = qr.phi;
+
+        // Sample BSDF to get new path direction
+
+        // Get _outgoingBSDFSample_ for sampling new path direction
+        BSDFSample outgoingBSDFSample;
+        if (bounces < SAMPLE_DEPTH) {
+          outgoingBSDFSample = BSDFSample(sample, pathSampleOffsets[bounces], 0);
+        }
+        else {
+          outgoingBSDFSample = BSDFSample(rng);
+        }
+        Vector wi;
+        float pdf;
+        BxDFType flags;
+        Spectrum f = bsdf->Sample_f(wo, &wi, outgoingBSDFSample, &pdf,
+                                    BSDF_ALL, &flags);
+        bounce_type[bounces] = flags;
+        Spectrum currAlbedo = bsdf->K();
+
+        // If the brdf has a diffuse component and we have not found the first
+        // rough bounce: this is it. we found our first
+        // diffuse interaction. The path is no longer purely specular.
+        bool isFirstRough = false;
+        if (!foundRough && bsdf_has_diffuse) {
+          foundRough = true;
+          isFirstRough = true;
+        } 
+
+        bool isFirstNonSpecular = false;
+        // If the brdf has a nonspecular component and we have not found any
+        // yet: this it is.
+        if (!foundNonSpecular && bsdf_has_nonspecular) {
+          foundNonSpecular = true;
+          isFirstNonSpecular = true;
+        } 
+
+        // Record depth, normal, albedo, visibility at first bounce
+        if (bounces == 0) {
+          Normal ssn(n);
+          if (Dot(ssn, ray.d) < 0) { //face forward
+            ssn.x *= -1.0f;
+            ssn.y *= -1.0f;
+            ssn.z *= -1.0f;
+          }
+
+          // Camera-space normals
+          Transform tx;
+          camera->CameraToWorld.Interpolate(sample->time, &tx);
+          nrm_at_first = Inverse(tx)(ssn);
+
+          depth_at_first = hitDistance;
+          albedo_at_first = currAlbedo;
+
+          // Flag whether light is directly visible (i.e. at first bounce)
+          isLightVisible = isLightVisible || qr.isLightVisible;
+        }
+
+        // record value at first nonspecular 
+        if (!recordedOutputValues && isFirstNonSpecular) {
+          recordedOutputValues = true;
+          depth = hitDistance;
+          albedo = currAlbedo;
+          Normal ssn(n);
+          if (Dot(ssn, ray.d) < 0) { //face forward
+            ssn.x *= -1.0f;
+            ssn.y *= -1.0f;
+            ssn.z *= -1.0f;
+          }
+
+          // Camera-space normals
+          Transform tx;
+          camera->CameraToWorld.Interpolate(sample->time, &tx);
+          nrm = Inverse(tx)(ssn);
+        } 
+
+        if (f.IsBlack() || pdf == 0.) { // Stop propagation
+          break;
+        } 
+
+        Spectrum bsdfWeight =  f * AbsDot(wi, n) / pdf;
+
+        if (bsdfWeight.HasNaNs()) {
+          Warning("Not-a-number in bsdfweight, setting to 0");
+          bsdfWeight = 0;
+        } else if (isinf(bsdfWeight.y())) {
+          Warning("Infinite bsdfweight, setting to 0");
+          bsdfWeight = 0;
+        }
+
+        pathThroughput *= bsdfWeight;
+        specularBounce = (flags & BSDF_SPECULAR) != 0;
+
+
+        // After the first rough bounce, the path is no longer purely specular,
+        // we accumulate radiance in the diffuse component
+        // TODO(mgharbi): this looks odd, should it be at all diffuse bounce? or after the first
+        if(isFirstRough) {
+          Spectrum bsdfWeightDiffuse = specularBounce ? Spectrum(0.0f) : 
+            bsdf->f(wo, wi, BxDFType(BSDF_DIFFUSE|BSDF_REFLECTION|BSDF_GLOSSY)) * AbsDot(wi, n) / pdf;
+          pathThroughputDiffuse *= bsdfWeightDiffuse;
+        } else {
+          pathThroughputDiffuse *= bsdfWeight;
+        }
+        
+        // Scatter
+        ray = RayDifferential(p, wi, ray, isectp->rayEpsilon);
+
+        if (bounces == maxDepth_)
+            break;
+
+        // Find next vertex of path
+        if (!scene->Intersect(ray, &localIsect)) {
+            if (specularBounce) {
+                for (uint32_t i = 0; i < scene->lights.size(); ++i) {
+                  Spectrum contrib = scene->lights[i]->Le(ray);
+                  L += contrib*pathThroughput;
+                  if (foundRough) {
+                    Ldiffuse += contrib*pathThroughputDiffuse;
+                    // if (bounces > 0)  {
+                    //   Ldiffuse_indirect += contrib*pathThroughputDiffuse;
+                    // }
+                  }
+                }
+            }
+            break;
+        }
+        Spectrum transmittance = renderer->Transmittance(scene, ray, NULL, rng, arena);
+        pathThroughput *= transmittance;
+        pathThroughputDiffuse *= transmittance;
+        isectp = &localIsect;
+    } // bounces loop
+
+    // Check fro NaNs
+    if (nrm_at_first.HasNaNs()) {
+      Error("normal first has nans");
+    }
+    if (nrm.HasNaNs()) {
+      Error("normal has nans");
+    }
+    if (albedo.HasNaNs()) {
+      Error("albedo has nans");
+    }
+    if (albedo_at_first.HasNaNs()) {
+      Error("albedo at first has nans");
+    }
+    if (albedo.y() > 101.0f || albedo_at_first.y() > 101.0f) {
+        Error("albedo is too high");
+    }
+    if (Ldiffuse.HasNaNs()) {
+        Warning("diffuse has nan, setting to 0");
+        Ldiffuse = 0;
+    }
+    if (L.HasNaNs()) {
+        Warning("L  has nan, setting to 0");
+        L = 0;
+    }
+
+    if (sr) {
+      // Store decomposed radiance
+      sr->radiance_diffuse.push_back(Ldiffuse);
+      // sr->radiance_diffuse_indirect.push_back(Ldiffuse_indirect);
+      sr->radiance_specular.push_back(L - Ldiffuse);
+
+      // Store features at first bounce
+      sr->normal_at_first.push_back(nrm_at_first);
+      sr->depth_at_first.push_back(depth_at_first);
+      sr->albedo_at_first.push_back(albedo_at_first);
+
+      // Store other features
+      sr->normal.push_back(nrm);
+      sr->depth.push_back(depth);
+      sr->visibility.push_back(isLightVisible ? 1.0 : 0.0);
+      sr->hasHit.push_back(1.0);
+      sr->albedo.push_back(albedo);
+      sr->probabilities.push_back(probabilities);
+      sr->light_directions.push_back(light_directions);
+      sr->bounce_type.push_back(bounce_type);
+    }
+
+    return RadianceQueryRecord(
+        L, Ldiffuse, albedo, nrm, depth, isLightVisible, true);
+}
+
+
+PathRendernetIntegrator *CreatePathRendernetSurfaceIntegrator(const ParamSet &params) {
+    int maxDepth = params.FindOneInt("maxdepth", 5);
+    return new PathRendernetIntegrator(maxDepth);
+}
diff -uarN pbrt/integrators/pathrendernet.h rendernet_pbrt/integrators/pathrendernet.h
--- pbrt/integrators/pathrendernet.h	1970-01-01 00:00:00.000000000 +0000
+++ rendernet_pbrt/integrators/pathrendernet.h	2019-09-07 01:14:54.000000000 +0000
@@ -0,0 +1,39 @@
+#if defined(_MSC_VER)
+#pragma once
+#endif
+
+#ifndef PBRT_INTEGRATORS_PATH_RENDERNET_H
+#define PBRT_INTEGRATORS_PATH_RENDERNET_H
+
+// integrators/pathrendernet.h*
+#include "pbrt.h"
+#include "integrator.h"
+#include "samplerecord.h"
+
+// PathRendernetIntegrator Declarations
+class PathRendernetIntegrator : public SurfaceIntegrator {
+public:
+    // PathRendernetIntegrator Public Methods
+    Spectrum Li(const Scene *scene, const Renderer *renderer,
+        const RayDifferential &ray, const Intersection &isect,
+        const Sample *sample, RNG &rng, MemoryArena &arena) const;
+    RadianceQueryRecord RecordedLi(const Scene *scene, const Renderer *renderer,
+        const RayDifferential &ray, const Intersection &isect,
+        const Sample *sample, RNG &rng, MemoryArena &arena, SampleRecord *sw, Camera *camera) const;
+    void RequestSamples(Sampler *sampler, Sample *sample, const Scene *scene);
+    PathRendernetIntegrator(int md) { maxDepth_ = md; }
+    virtual int maxDepth() {return maxDepth_;};
+private:
+    int maxDepth_;
+    // PathRendernetIntegrator Private Data
+#define SAMPLE_DEPTH 3
+    LightSampleOffsets lightSampleOffsets[SAMPLE_DEPTH];
+    int lightNumOffset[SAMPLE_DEPTH];
+    BSDFSampleOffsets bsdfSampleOffsets[SAMPLE_DEPTH];
+    BSDFSampleOffsets pathSampleOffsets[SAMPLE_DEPTH];
+};
+
+
+PathRendernetIntegrator *CreatePathRendernetSurfaceIntegrator(const ParamSet &params);
+
+#endif // PBRT_INTEGRATORS_PATH_RENDERNET_H
diff -uarN pbrt/pbrt.vs2008/pbrt.suo rendernet_pbrt/pbrt.vs2008/pbrt.suo
--- pbrt/pbrt.vs2008/pbrt.suo	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/pbrt.vs2008/pbrt.suo	1970-01-01 00:00:00.000000000 +0000
@@ -1,7 +0,0 @@
-                >  	                                                         	      
-                                 !                                  "   $   '   (   )   *   +   ,   -   .   #   R o o t   E n t r y                                               	                               p   /      P r o j I n f o E x                                                                                              T a s k L i s t U s e r T a s k s                               $                                                     D e b u g g e r W a t c h e s                                                                                       '         	   
-                                                       !   )   #   [   *   t   ,   -   .   /   0   1   2   3   4   5   6   7   8   9   :   ;   <   =   >   ?   @   A   B   C   D   E   F   G   H   I   J   K   L   M   N   O   P   Q   R   S   T   U   V   W   X   Y   Z   \   k   ^   _   `   a   b   d   e   f   g   i   j   l   m   n   o   p   q   r   s   w   u   v      x   y   z   {   |   ~      "d{C)                                                C	                                                                                                                               |   C : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ p b r t . v s 2 0 0 8                                                                           ~   c : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   V i s u a l   S t u d i o   9 . 0 \ V C \ c r D e b u g g e r B r e a k p o i n t s                           (                                                  D e b u g g e r E x c e p t i o n s                             &                                                  D e b u g g e r F i n d S o u r c e                             &                                           F      D e b u g g e r F i n d S y m b o l                             &                                              t \ s r c \      c : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   V i s u a l   S t u d i o   9 . 0 \ V C \ a t l m f c \ s r c \ m f c \      c : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   V i s u a l   S t u d i o   9 . 0 \ V C \ a t l m f c \ s r c \ a t l \      c : \ P r o g r a m   F i l e s   ( x 8 6 ) \ M i c r o s o f t   V i s u a l   S t u d i o   9 . 0 \ V C \ a t l m f c \ i n c l u d e \                                                                     D e b u g g e r M e m o r y W i n d o w s                       ,                                               T       E x t e r n a l F i l e s P r o j e c t C o n t e n t s         : 
-                                               D o c u m e n t W i n d o w P o s i t i o n s                   0                                                  D o c u m e n t W i n d o w U s e r D a t a                     .                                                                                                                                                                                                                                                                                                              M u l t i S t a r t u p P r o j   =      ; 4   { A 3 2 D C Q    C : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ p b r t . v s 2 0 0 8 \ b s d f t e s t . v c p r o j         C : \ U s e r s \ r o b S o l u t i o n C o n f i g u r a t i o n                       ,                                     &         O b j M g r C o n t e n t s V 8                                 "                                                C l a s s V i e w C o n t e n t s                               $                                                   P r o j E x p l o r e r S t a t e                               $                                              
-      e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ p b r t . v s 2 0 0 8 \ e x r a v g . v c p r o j         C : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ p b r t . v s 2 0 0 8 \ e x r d i f f . v c p r o j         C : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ p b r t . v s 2 0 0 8 \ e x r t o t i f f . v c p r o j         C : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ p b r t . v s 2 0 0 8 \ l i b p b r t . v c p r o j         C : \ U s e r s \ r o 	    c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ c o r e \ p b r t l e x $ B o o k m a r k s   V 0 0 1 . 0 1                             X
-     k m a r k s   V 0 0 1 . 0 1                                                                                            \                                                               U n l o a d e d P r o j e c t s                                 "                                              H i d d e n S l n F o l d e r s                                 "                                                   O u t l i n i n g S t a t e D i r                               $                                      "         B o o k m a r k S t a t e                                                                                  $   (       T a s k L i s t S h o r t c u t s                               $                                      %          V s T o o l b o x S e r v i c e                                 "                                         (          P r o p e r t y   M a n a g e r                                 "                                           &          O u t l i n i n g S t a t e 1                                                                               +                                                                         b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ p b r t . v s 2 0 0 8 \ p b r t . v c p r o j       c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ c o r e \ p b r t l e x . c p p   B               #                         =   !      0         1   #   7         ;   %   <         >   )   ?         A   .   B         D   $   E         G   &   H         J   +   K         M   %   N         P   '   Q         S   ,   T                V         Y       ]         ^      e         h      i         j      k                     "      0                                                                                                                                                  !                      $   m        n     r         s                                                                                !                                                                         E     F        G     H        D     I        L  9   M        P  ,   Q        V     W        X     Y        T      [        _     `        d  /   h        n                $                          1                                                                             "  0   $        +     -     $                             5                            L                                                                                                                                    (                                $     (        8     <     <   !      ?     (   @      G         H     M        X     Z     ?   N      e         f     i     /   j      x        y     z         }                       B                                         .                            6                                                                     (                            ?         8         9     @     6   A      F         G     M        d     f     K   N      k        l     m     /   p      u         v                                                                                                                                                       %                                          !                                                                                              !                 	  7   	              	         		      	        	     	        	     	         !	      %	        (	     .	     /   &	      1	        2	      6	         7	      ;	        <	      E	                            . c p p       c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ 3 r d p a r t  c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ 3 r d p a r t y \ t i f f - 3 . 9 . 4 \ m k g 3 s t a t e s . c                      $ O u t l i n i n g S t a t e 2                                                                         ]   |      O u t l i n i n g S t a t e 3                                                                               c         O u t l i n i n g S t a t e 4                                                                         h          O u t l i n i n g S t a t e 5                                                                                                  %      &         +   &   ,         6       :          ;       =     A   ?      Q         R      W     H   Y      y        |                              c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ 3 r d p a r t y \ o p e n e x r - 1 . 7 . 0 \ b 4 4 E x p L o g T a b l e . c p p   9                   =         A   )   B         C   3   D         ?                                                       c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ c o r e \ p r o b e s . c p p   G!                 d                f          y \ t i f f - 3 . 9 . 4 \ m k g 3 s t a t e s . c      z c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ t o o l s \ p l y . c       c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ c o r e \ p r o b e s . c p p       c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ t o o l s \ p l y 2 p b r t . c       c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ 3 r d p a r t y \    C : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ p b r t . v s 2 0 0 8 \ p l y 2 p b r t . v c p r o j         C : \ U s e r s \ r o b e o p e n e x r - 1 . 7 . 0 \ b 4 4 E x p L o g T a b l e . c p p      ~ c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ m a i n \ p b r t . c p p       c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ t o o l s \ e x r t o t i f f . c p p        P r o j   =      ; 4   { A 3 2 D C z c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ t o o l s \ p l y . c   x       &   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3                                                  c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ t o o l s \ p l y 2 p b r t . c   Q                                   %         %       &         '      +         +       V         X       n          o       r         t       y          z       }                                                     D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { A 3 ~ c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ m a i n \ p b r t . c p p   v                                   L               r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ p b r t . v s 2 0 0 8 \ t i f f t o e x r . v c p r o j          : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b    M u l t i S t a r t u p P r o j   =      ; 4   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . d w S t a r t u p O p t   =      ;    S t a r t u p P r o j e c t   =  &   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } ; =   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . d w S t a r t u p O p t   =      ; =   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . d w S t a r t u p O p t   =      ; =   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 7 2 B } . d w S t a r t u p O p t   =      ; =   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 7 2 B } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 7 2 B } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 7 2 B } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 O u t l i n i n g S t a t e 6                                                                                  O u t l i n i n g S t a t e 7                                                                               }          O u t l i n i n g S t a t e 8                                                                                                                                                                                                        c : \ U s e r s \ r o b e r t \ D o w n l o a d s \ p b r t - v 2 - 2 0 1 0 . 1 0 . 2 0 \ s r c \ t o o l s \ e x r t o t i f f . c p p   jP                                   &          -   H   .          2   +   3      +   '       A      ,   B       E         Y   >   Z         G       |             A             }             P               Y         (                                                          7 2 B } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 9 4 } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { 9 C B E A 1 B 6 - 2 7 2 9 - 4 9 E 3 - 8 3 8 8 - 4 D E D 9 9 8 2 E 4 9 4 } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { 1 2 7 E F D 1 0 - 7 1 0 8 - 4 7 E 7 - B 3 C A - 7 F 2 6 9 A 5 C F B C 2 } . d w S t a r t u p O p t   =      ; =   { 1 2 7 E F D 1 0 - 7 1 0 8 - 4 7 E 7 - B 3 C A - 7 F 2 6 9 A 5 C F B C 2 } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { 1 2 7 E F D 1 0 - 7 1 0 8 - 4 7 E 7 - B 3 C A - 7 F 2 6 9 A 5 C F B C 2 } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { 1 2 7 E F D 1 0 - 7 1 0 8 - 4 7 E 7 - B 3 C A - 7 F 2 6 9 A 5 C F B C 2 } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { 1 2 7 E F D 1 0 - 7 1 0 8 - 4 7 E 7 - B 3 C A - 7 F 2 6 9 A 5 C F B C 2 } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 
-   A c t i v e C f g   =  	   D e b u g | x 8 6 ;      ; ?   { 2 4 8 E 5 C 1 5 - 9 E 5 B - 4 D 6 B - 9 F 1 F - 8 3 2 C 2 2 D 9 0 9 8 1 } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { 2 4 8 E 5 C 1 5 - 9 E 5 B - 4 D 6 B - 9 F 1 F - 8 3 2 C 2 2 D 9 0 9 8 1 } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { 2 4 8 E 5 C 1 5 - 9 E 5 B - 4 D 6 B - 9 F 1 F - 8 3 2 C 2 2 D 9 0 9 8 1 } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   0 C } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . R e l e    M u l t i S t a r t u p P r o j   =      ; 4   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . d w S t a r t u p O p t   =      ;    S t a r t u p P r o j e c t   =  &   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } ; =   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { A 3 2 D C 5 C 9 - 5 3 5 3 - 4 E A A - B B 1 3 - D 0 8 C D B 7 F A 0 0 C } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . d w S t a r t u p O p t   =      ; =   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { A 4 B C E F 8 0 - A 8 6 4 - 4 0 D F - 9 4 B 1 - 0 E 0 E 6 1 C E C 7 C C } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . d w S t a r t u p O p t   =      ; =   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { 4 A 0 F 3 2 8 F - 2 3 8 2 - 4 E 4 9 - 9 7 0 1 - 3 8 5 D 7 2 7 1 7 D 2 E } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 7 2 B } . d w S t a r t u p O p t   =      ; =   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 7 2 B } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 7 2 B } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 7 2 B } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { B D A 7 3 6 D E - 7 2 4 E - 4 E 1 0 - A 4 B 3 - 2 A 5 E F 7 3 6 6 7 2 B } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { E A 8 5 6 7 3 9 - F D A E - 4 7 5 A - A 5 3 E - F 1 7 E 6 7 3 F E 4 B 7 } . d w S t a r t u p O p t   =      ; =   { E A 8 5 6 7 3 9 - F D A E - 4 7 5 A - A 5 3 E - F 1 7 E 6 7 3 F E 4 B 7 } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { E A 8 5 6 7 3 9 - F D A E - 4 7 5 A - A 5 3 E - F 1 7 E 6 7 3 F E 4 B 7 } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { E A 8 5 6 7 3 9 - F D A E - 4 7 5 A - A 5 3 E - F 1 7 E 6 7 3 F E 4 B 7 } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { E A 8 5 6 7 3 9 - F D A E - 4 7 5 A - A 5 3 E - F 1 7 E 6 7 3 F E 4 B 7 } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { 2 4 8 E 5 C 1 5 - 9 E 5 B - 4 D 6 B - 9 F 1 F - 8 3 2 C 2 2 D 9 0 9 8 1 } . d w S t a r t u p O p t   =      ; =   { 2 4 8 E 5 C 1 5 - 9 E 5 B - 4 D 6 B - 9 F 1 F - 8 3 2 C 2 2 D 9 0 9 8 1 } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { 2 4 8 E 5 C 1 5 - 9 E 5 B - 4 D 6 B - 9 F 1 F - 8 3 2 C 2 2 D 9 0 9 8 1 } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { 2 4 8 E 5 C 1 5 - 9 E 5 B - 4 D 6 B - 9 F 1 F - 8 3 2 C 2 2 D 9 0 9 8 1 } . D e b u g | x 6 4 . f B a t c h B l d   =      ; =   { 2 4 8 E 5 C 1 5 - 9 E 5 B - 4 D 6 B - 9 F 1 F - 8 3 2 C 2 2 D 9 0 9 8 1 } . D e b u g | W i n 3 2 . f B a t c h B l d   =      ; 4   { 9 C B E A 1 B 6 - 2 7 2 9 - 4 9 E 3 - 8 3 8 8 - 4 D E D 9 9 8 2 E 4 9 4 } . d w S t a r t u p O p t   =      ; =   { 9 C B E A 1 B 6 - 2 7 2 9 - 4 9 E 3 - 8 3 8 8 - 4 D E D 9 9 8 2 E 4 9 4 } . R e l e a s e | x 6 4 . f B a t c h B l d   =      ; ?   { 9 C B E A 1 B 6 - 2 7 2 9 - 4 9 E 3 - 8 3 8 8 - 4 D E D 9 9 8 2 E 4 9 4 } . R e l e a s e | W i n 3 2 . f B a t c h B l d   =      ; ;   { 9 C B E A 1 B 6 - 2 7 2 9 - 4 9 E 3 - 8 3 8 8 - 4 D E D 9 9 8 2 E 4 
\ No newline at end of file
diff -uarN pbrt/renderers/rendernetrenderer.cpp rendernet_pbrt/renderers/rendernetrenderer.cpp
--- pbrt/renderers/rendernetrenderer.cpp	1970-01-01 00:00:00.000000000 +0000
+++ rendernet_pbrt/renderers/rendernetrenderer.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -0,0 +1,421 @@
+
+/*
+    pbrt source code Copyright(c) 1998-2012 Matt Pharr and Greg Humphreys.
+
+    This file is part of pbrt.
+
+    Redistribution and use in source and binary forms, with or without
+    modification, are permitted provided that the following conditions are
+    met:
+
+    - Redistributions of source code must retain the above copyright
+      notice, this list of conditions and the following disclaimer.
+
+    - Redistributions in binary form must reproduce the above copyright
+      notice, this list of conditions and the following disclaimer in the
+      documentation and/or other materials provided with the distribution.
+
+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS
+    IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
+    TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
+    PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+ */
+
+
+// renderers/samplerrenderer.cpp*
+#include "stdafx.h"
+#include "renderers/rendernetrenderer.h"
+#include "integrators/pathrendernet.h"
+#include "integrators/pathkpcn.h"
+#include "scene.h"
+#include "film.h"
+#include "volume.h"
+#include "sampler.h"
+#include "integrator.h"
+#include "progressreporter.h"
+#include "camera.h"
+#include "intersection.h"
+#include "montecarlo.h"
+#include "cameras/perspective.h"
+#include "time.h"
+
+#include <typeinfo>
+
+static uint32_t hash(char *key, uint32_t len)
+{
+    uint32_t hash = 0, i;
+    for (hash=0, i=0; i<len; ++i) {
+        hash += key[i];
+        hash += (hash << 10);
+        hash ^= (hash >> 6);
+    }
+    hash += (hash << 3);
+    hash ^= (hash >> 11);
+    hash += (hash << 15);
+    return hash;
+} 
+
+bool RendernetRenderer::is_kpcn() const {
+  PathKPCNIntegrator* p = dynamic_cast<PathKPCNIntegrator*>(surfaceIntegrator);
+  if(p) {
+    return true;
+  }
+  return false;
+}
+
+// RendernetRendererTask Definitions
+void RendernetRendererTask::Run() {
+    PBRT_STARTED_RENDERTASK(taskNum);
+    // Get sub-_Sampler_ for _RendernetRendererTask_
+    //
+    Sampler* samplers[2] = {
+      mainSampler->GetSubSampler(taskNum, taskCount), 
+      recordedSampler->GetSubSampler(taskNum, taskCount)
+    };
+
+    Sample* origSamples[2] = {
+      origSample,
+      recordedOrigSample,
+    };
+
+    for (int i = 0; i < 2; ++i) {
+      if (!samplers[i]) {
+          reporter.Update();
+          PBRT_FINISHED_RENDERTASK(taskNum);
+          return;
+      }
+    }
+
+    // Declare local variables used for rendering loop
+    MemoryArena arena;
+    // TODO(mgharbi): not sure why we changed this
+    RNG rng(time(NULL)); // RNG rng(taskNum);
+
+    Point sceneCenter;
+    float sceneRadius;
+    scene->WorldBound().BoundingSphere(&sceneCenter, &sceneRadius);
+
+    PerspectiveCamera *pcam = dynamic_cast<PerspectiveCamera*>(camera);
+    if (!pcam) {
+      Error("Rendernet only supports ProjectiveCamera\n");
+      return;
+    }
+
+    int xstart, xend, ystart, yend;
+    camera->film->GetPixelExtent(&xstart, &xend, &ystart, &yend);
+
+    SampleRecord *sr = new SampleRecord(
+        samplers[0]->xPixelStart-xstart,
+        samplers[1]->yPixelStart-ystart,
+        renderer->tileSize, 
+        samplers[1]->samplesPerPixel,  // Saved samples
+        samplers[0]->samplesPerPixel,  // Image reference
+        renderer->maxDepth,
+        xend-xstart,
+        yend-ystart,
+        sceneRadius, pcam->focalDistance,
+        pcam->lensRadius, pcam->fov,
+        renderer->useCameraSpaceNormals
+        );
+
+    if(renderer->is_kpcn()) {
+      sr->set_kpcn();
+    }
+
+    // Allocate space for samples and intersections
+    for (int sampler_idx = 0; sampler_idx < 2; ++sampler_idx) {
+      Sampler *sampler = samplers[sampler_idx];
+
+      int maxSamples = sampler->MaximumSampleCount();
+      Sample *samples = origSamples[sampler_idx]->Duplicate(maxSamples);
+      RayDifferential *rays = new RayDifferential[maxSamples];
+      Spectrum *Ls = new Spectrum[maxSamples];
+      Spectrum *Ts = new Spectrum[maxSamples];
+      Intersection *isects = new Intersection[maxSamples];
+
+      // Get samples from _Sampler_ and update image
+      int sampleCount;
+      int pixel_id = 0;
+      while ((sampleCount = sampler->GetMoreSamples(samples, rng)) > 0) {
+        RadianceQueryRecord rq_rec;
+
+        // Generate camera rays and compute radiance along rays
+        for (int i = 0; i < sampleCount; ++i) {
+          // Find camera ray for _sample[i]_
+          PBRT_STARTED_GENERATING_CAMERA_RAY(&samples[i]);
+          float rayWeight = camera->GenerateRayDifferential(samples[i], &rays[i]);
+
+          // TODO(mgharbi): this scaling was inconsistent between our lowspp
+          // data and the ground-truth so we fix it to a constant
+            rays[i].ScaleDifferentials(1.f / sqrtf(8192));
+          // rays[i].ScaleDifferentials(1.f / sqrtf(sampler->samplesPerPixel));
+
+          PBRT_FINISHED_GENERATING_CAMERA_RAY(&samples[i], &rays[i], rayWeight);
+
+          // Evaluate radiance along camera ray
+          // PBRT_STARTED_CAMERA_RAY_INTEGRATION(&rays[i], &samples[i]);
+          if (sampler_idx == 1) {
+            // we save the sample, and ignore the buffer data
+            RadianceQueryRecord ret = renderer->RecordedLi(scene, rays[i], &samples[i], rng,
+                arena, &isects[i], &Ts[i], sr); 
+
+            // Record sample data
+            int pix_x = pixel_id % renderer->tileSize + sr->tile_x;
+            int pix_y = pixel_id / renderer->tileSize + sr->tile_y;
+            float lensU, lensV;
+            ConcentricSampleDisk(samples[i].lensU, samples[i].lensV, &lensU, &lensV);
+            lensU *= sr->aperture_radius;
+            lensV *= sr->aperture_radius;
+            sr->pixel_x.push_back((float) pix_x);
+            sr->pixel_y.push_back((float) pix_y);
+            sr->subpixel_x.push_back(samples[i].imageX-(float)pix_x);
+            sr->subpixel_y.push_back(samples[i].imageY-(float)pix_y);
+            sr->lens_u.push_back(lensU);
+            sr->lens_v.push_back(lensV);
+            sr->time.push_back(samples[i].time);
+          } else {
+            RadianceQueryRecord ret = renderer->RecordedLi(scene, rays[i], &samples[i], rng,
+                arena, &isects[i], &Ts[i], NULL);
+            rq_rec.add(ret, rayWeight);
+          }
+
+          // TODO(mgharbi) 2019-03-06 Hack to compute the grountruth, sum diffuse + specular
+          float rgb_d[3];
+          float rgb_s[3];
+          for (int ridx = 0; ridx < 3; ++ridx) {
+            rgb_d[ridx] =  rq_rec.buffer[ridx];
+            rgb_s[ridx] =  rq_rec.buffer[3+ridx];
+          }
+          Ls[i] = RGBSpectrum::FromRGB(rgb_d) + RGBSpectrum::FromRGB(rgb_s);
+          PBRT_FINISHED_CAMERA_RAY_INTEGRATION(&rays[i], &samples[i], &Ls[i]);
+        } // spp loop
+        
+        // We're constructing an image
+        if( sampler_idx == 0 ) {
+          // Add pixel data to .bin record
+          sr->add_image_sample(rq_rec, sampler_idx);
+        }
+        
+        // Report sample results to _Sampler_, add contributions to image
+        if (sampler_idx == 0 && sampler->ReportResults(samples, rays, Ls, isects, sampleCount))
+        {
+            for (int i = 0; i < sampleCount; ++i)
+            {
+                PBRT_STARTED_ADDING_IMAGE_SAMPLE(&samples[i], &rays[i], &Ls[i], &Ts[i]);
+                camera->film->AddSample(samples[i], Ls[i]);
+                PBRT_FINISHED_ADDING_IMAGE_SAMPLE();
+            }
+        }
+
+
+        // Free _MemoryArena_ memory from computing image sample values
+        arena.FreeAll();
+
+        // Increment pixel counter
+        pixel_id += 1;
+      }
+
+      delete[] samples;
+      delete[] rays;
+      delete[] Ls;
+      delete[] Ts;
+      delete[] isects;
+    } // Loop over samplers
+    
+    // Write sample data
+    sprintf(fname, "%04d_%04d.bin", samplers[0]->xPixelStart, samplers[0]->yPixelStart);
+    sr->save(fname);
+
+    // Clean up after _SamplerRendererTask_ is done with its image region
+    camera->film->UpdateDisplay(samplers[0]->xPixelStart,
+        samplers[0]->yPixelStart, samplers[0]->xPixelEnd+1, samplers[0]->yPixelEnd+1);
+    delete sr;
+    for (int i = 0; i < 2; ++i) {
+      delete samplers[i];
+    }
+    reporter.Update();
+    PBRT_FINISHED_RENDERTASK(taskNum);
+}
+
+
+
+// RendernetRenderer Method Definitions
+RendernetRenderer::RendernetRenderer(Sampler *s, Sampler *s2, Sampler *rs, Camera *c,
+                                 SurfaceIntegrator *si, VolumeIntegrator *vi,
+                                 int tSz, int recSamples, bool useCamSpaceNrm) {
+    sampler = s;
+    // sampler2 = s2;
+    sampler_recorded = rs;
+    camera = c;
+    surfaceIntegrator = si;
+    volumeIntegrator = vi;
+    tileSize = tSz;
+    recordedSamples = recSamples;
+    useCameraSpaceNormals = useCamSpaceNrm;
+
+    maxDepth = surfaceIntegrator->maxDepth();
+    if(maxDepth != 5) {
+      Error("Rendernet's sampler structure only supports path length 5.\n");
+    }
+}
+
+
+RendernetRenderer::~RendernetRenderer() {
+    delete sampler;
+    // delete sampler2;
+    delete sampler_recorded;
+    delete camera;
+    delete surfaceIntegrator;
+    delete volumeIntegrator;
+}
+
+
+void RendernetRenderer::Render(const Scene *scene) {
+    PBRT_FINISHED_PARSING();
+    // Allow integrators to do preprocessing for the scene
+    PBRT_STARTED_PREPROCESSING();
+    surfaceIntegrator->Preprocess(scene, camera, this);
+    volumeIntegrator->Preprocess(scene, camera, this);
+    PBRT_FINISHED_PREPROCESSING();
+    PBRT_STARTED_RENDERING();
+    // Allocate and initialize _sample_
+    Sample *sample = new Sample(sampler, surfaceIntegrator,
+                                volumeIntegrator, scene);
+    // Sample *sample2 = new Sample(sampler2, surfaceIntegrator,
+    //                             volumeIntegrator, scene);
+    Sample *rsample = new Sample(sampler_recorded, surfaceIntegrator,
+                                volumeIntegrator, scene);
+
+    // Create and launch _RendernetRendererTask_s for rendering image
+
+    // Compute number of _RendernetRendererTask_s to create for rendering
+    
+    int xstart, xend, ystart, yend;
+    camera->film->GetPixelExtent(&xstart, &xend, &ystart, &yend);
+    int xRes = xend-xstart;
+    int yRes = yend-ystart;
+    if(xRes % tileSize != 0) {
+      Error("tile size does not divide xRes");
+      return;
+    }
+    if(yRes % tileSize != 0) {
+      Error("tile size does not divide yRes");
+      return;
+    }
+    int nTasks = xRes*yRes / (tileSize*tileSize);
+
+    printf("Resolution %dx%d, %d tiles with size %d. References with %d samples. Input with %d samples)\n",
+        xRes, yRes, nTasks, tileSize, sampler->samplesPerPixel, sampler_recorded->samplesPerPixel);
+
+    ProgressReporter reporter(nTasks, "Rendering");
+    vector<Task *> renderTasks;
+    for (int i = 0; i < nTasks; ++i) {
+      renderTasks.push_back(
+          new RendernetRendererTask(
+            scene, this, camera, reporter, sampler,
+            sampler_recorded, sample, rsample, nTasks-1-i, nTasks));
+    }
+    EnqueueTasks(renderTasks);
+    WaitForAllTasks();
+
+    for (uint32_t i = 0; i < renderTasks.size(); ++i) {
+      delete renderTasks[i];
+    }
+
+    reporter.Done();
+    PBRT_FINISHED_RENDERING();
+    // Clean up after rendering and store final image
+    delete sample;
+    // delete sample2;
+    delete rsample;
+    camera->film->WriteImage();
+}
+
+Spectrum RendernetRenderer::Li(const Scene *scene,
+        const RayDifferential &ray, const Sample *sample, RNG &rng,
+        MemoryArena &arena, Intersection *isect, Spectrum *T) const {
+  // return RecordedLi(scene, ray, sample, rng, arena, isect, T, NULL).L;
+  throw;
+  return Spectrum(0.0f);
+}
+
+
+RadianceQueryRecord RendernetRenderer::RecordedLi(const Scene *scene,
+        const RayDifferential &ray, const Sample *sample, RNG &rng,
+        MemoryArena &arena, Intersection *isect, Spectrum *T, SampleRecord * sr) const {
+    Assert(ray.time == sample->time);
+    Assert(!ray.HasNaNs());
+    // Allocate local variables for _isect_ and _T_ if needed
+    Spectrum localT;
+    if (!T) T = &localT;
+    Intersection localIsect;
+    if (!isect) isect = &localIsect;
+    RadianceQueryRecord rq_rec;
+
+    if (scene->Intersect(ray, isect)) {
+        rq_rec = surfaceIntegrator->RecordedLi(
+            scene, this, ray, *isect, sample, rng, arena, sr, camera);
+    } else { // No intersection
+
+        // Handle ray that doesn't intersect any geometry
+        Spectrum Li;
+        for (uint32_t i = 0; i < scene->lights.size(); ++i) {
+           Li += scene->lights[i]->Le(ray);
+        }
+
+        Normal default_n;
+        rq_rec = RadianceQueryRecord(
+            Li, Spectrum(0.0f), Spectrum(0.0f), default_n, -1.0f, false, false);
+
+        if(sr) {
+          // Transform tx;
+          // camera->CameraToWorld.Interpolate(sample->time, &tx);
+          Spectrum zero = 0.;
+          sr->radiance_specular.push_back(Li); // We only have the scene lights/envmap contributions
+          sr->radiance_diffuse.push_back(zero);
+          // sr->radiance_diffuse_indirect.push_back(zero);
+
+          sr->albedo_at_first.push_back(Spectrum(0.0f));
+          sr->normal_at_first.push_back(default_n);
+          sr->depth_at_first.push_back(-1.0f);  // no intersection
+
+          sr->albedo.push_back(Spectrum(0.0f));
+          sr->normal.push_back(default_n);
+          sr->depth.push_back(-1.0f);  // no intersection
+
+          sr->visibility.push_back(0.0f);
+          sr->hasHit.push_back(0.0f);
+
+          std::vector<float> p(4*sr->maxDepth);
+          sr->probabilities.push_back(p);
+          std::vector<float> ld(2*sr->maxDepth);
+          sr->light_directions.push_back(ld);
+          std::vector<uint16_t> bt(sr->maxDepth);
+          sr->bounce_type.push_back(bt);
+        }
+    }
+    // NOTE(mgharbi): volume not accounted for, for now
+    // Spectrum Lvi = volumeIntegrator->Li(scene, this, ray, sample, rng,
+    //                                     T, arena);
+    
+    // TODO: multiply radiance by *T if using transmissive media
+    return rq_rec;
+}
+
+
+Spectrum RendernetRenderer::Transmittance(const Scene *scene,
+        const RayDifferential &ray, const Sample *sample, RNG &rng,
+        MemoryArena &arena) const {
+    return volumeIntegrator->Transmittance(scene, this, ray, sample,
+                                           rng, arena);
+}
+
+
diff -uarN pbrt/renderers/rendernetrenderer.h rendernet_pbrt/renderers/rendernetrenderer.h
--- pbrt/renderers/rendernetrenderer.h	1970-01-01 00:00:00.000000000 +0000
+++ rendernet_pbrt/renderers/rendernetrenderer.h	2019-09-07 01:14:54.000000000 +0000
@@ -0,0 +1,89 @@
+#if defined(_MSC_VER)
+#pragma once
+#endif
+
+#ifndef PBRT_RENDERERS_RENDERNETRENDERER_H
+#define PBRT_RENDERERS_RENDERNETRENDERER_H
+
+// renderers/rendernetrenderer.h*
+#include "pbrt.h"
+#include "renderer.h"
+#include "parallel.h"
+#include "samplerecord.h"
+
+
+// RendernetRenderer Declarations
+class RendernetRenderer : public Renderer {
+public:
+    // RendernetRenderer Public Methods
+    RendernetRenderer(
+        Sampler *s, Sampler *s2, Sampler *rs, Camera *c, SurfaceIntegrator *si,
+        VolumeIntegrator *vi, int tileSize, 
+        int recordedSamples, bool useCameraSpaceNormals);
+    ~RendernetRenderer();
+    void Render(const Scene *scene);
+    Spectrum Li(const Scene *scene, const RayDifferential &ray,
+        const Sample *sample, RNG &rng, MemoryArena &arena,
+        Intersection *isect = NULL, Spectrum *T = NULL) const;
+    RadianceQueryRecord RecordedLi(const Scene *scene, const RayDifferential &ray,
+        const Sample *sample, RNG &rng, MemoryArena &arena,
+        Intersection *isect = NULL, Spectrum *T = NULL, SampleRecord *sr = NULL) const;
+    Spectrum Transmittance(const Scene *scene, const RayDifferential &ray,
+        const Sample *sample, RNG &rng, MemoryArena &arena) const;
+    int tileSize;
+    int recordedSamples;
+    int maxDepth;
+    bool useCameraSpaceNormals;
+    bool is_kpcn() const;
+private:
+    // RendernetRenderer Private Data
+    Sampler *sampler;
+    // Sampler *sampler2;
+    Sampler *sampler_recorded;
+    Camera *camera;
+    SurfaceIntegrator *surfaceIntegrator;
+    VolumeIntegrator *volumeIntegrator;
+};
+
+
+
+// RendernetRendererTask Declarations
+class RendernetRendererTask : public Task {
+public:
+    // RendernetRendererTask Public Methods
+    RendernetRendererTask(const Scene *sc, RendernetRenderer *ren, Camera *c,
+                        ProgressReporter &pr, 
+                        Sampler *ms, Sampler* rs,
+                        Sample *sam, Sample *rsam,
+                        int tn, int tc)
+      : reporter(pr)
+    {
+        scene = sc; renderer = ren; camera = c; 
+        mainSampler = ms; 
+        recordedSampler = rs;
+        origSample = sam; 
+        recordedOrigSample = rsam; 
+        taskNum = tn; taskCount = tc;
+    }
+    void Run();
+
+    char fname[64];
+private:
+    // RendernetRendererTask Private Data
+    const Scene *scene;
+    const RendernetRenderer *renderer;
+    Camera *camera;
+    Sampler *mainSampler;
+    // Sampler *mainSampler2;
+    Sampler *recordedSampler;
+    ProgressReporter &reporter;
+    Sample *origSample;
+    // Sample *origSample2;
+    Sample *recordedOrigSample;
+    int taskNum, taskCount;
+
+};
+
+
+
+#endif // PBRT_RENDERERS_RENDERNETRENDERER_H
diff -uarN pbrt/renderers/samplerrenderer.cpp rendernet_pbrt/renderers/samplerrenderer.cpp
--- pbrt/renderers/samplerrenderer.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/renderers/samplerrenderer.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -88,7 +88,8 @@
             // Find camera ray for _sample[i]_
             PBRT_STARTED_GENERATING_CAMERA_RAY(&samples[i]);
             float rayWeight = camera->GenerateRayDifferential(samples[i], &rays[i]);
-            rays[i].ScaleDifferentials(1.f / sqrtf(sampler->samplesPerPixel));
+            rays[i].ScaleDifferentials(1.f / sqrtf(8192));
+            // rays[i].ScaleDifferentials(1.f / sqrtf(sampler->samplesPerPixel));
             PBRT_FINISHED_GENERATING_CAMERA_RAY(&samples[i], &rays[i], rayWeight);
 
             // Evaluate radiance along camera ray
diff -uarN pbrt/renderers/samplerrenderer.h rendernet_pbrt/renderers/samplerrenderer.h
--- pbrt/renderers/samplerrenderer.h	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/renderers/samplerrenderer.h	2019-09-07 01:14:54.000000000 +0000
@@ -45,8 +45,8 @@
 class SamplerRenderer : public Renderer {
 public:
     // SamplerRenderer Public Methods
-    SamplerRenderer(Sampler *s, Camera *c, SurfaceIntegrator *si,
-                    VolumeIntegrator *vi, bool visIds);
+    SamplerRenderer(Sampler *s, Camera *c, SurfaceIntegrator *si, 
+        VolumeIntegrator *vi, bool visIds);
     ~SamplerRenderer();
     void Render(const Scene *scene);
     Spectrum Li(const Scene *scene, const RayDifferential &ray,
diff -uarN pbrt/shapes/disk.cpp rendernet_pbrt/shapes/disk.cpp
--- pbrt/shapes/disk.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/shapes/disk.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -85,7 +85,7 @@
     float v = 1.f - oneMinusV;
     Vector dpdu(-phiMax * phit.y, phiMax * phit.x, 0.);
     Vector dpdv(phit.x, phit.y, 0.);
-    dpdv *= (radius - innerRadius) / R;
+    dpdv *= (innerRadius - radius) / R;
     Normal dndu(0,0,0), dndv(0,0,0);
 
     // Initialize _DifferentialGeometry_ from parametric information
diff -uarN pbrt/tools/obj2pbrt.cpp rendernet_pbrt/tools/obj2pbrt.cpp
--- pbrt/tools/obj2pbrt.cpp	2019-09-07 01:14:52.000000000 +0000
+++ rendernet_pbrt/tools/obj2pbrt.cpp	2019-09-07 01:14:54.000000000 +0000
@@ -20,7 +20,9 @@
 
 #include <string>
 #include <vector>
+#include <algorithm>
 #include <map>
+#include <cmath>
 
 namespace tinyobj {
 
@@ -903,6 +905,11 @@
     return 1;
   }
 
+  bool normalize_uvs = true;
+  // if (normalize_uvs) {
+  //   fprintf(stderr, "normalizing uvs\n");
+  // }
+
   std::vector<shape_t> shapes;
   const char *mtl_basepath = ""; // ?
   std::string errs = LoadObj(shapes, argv[1], mtl_basepath);
@@ -928,10 +935,10 @@
       bounds[1][c] = std::max(bounds[1][c], mesh.positions[i]);
     }
   }
-  fprintf(f, "# Converted from \"%s\" by obj2pbrt\n", argv[1]);
-  fprintf(f, "# Scene bounds: (%f, %f, %f) - (%f, %f, %f)\n\n\n",
-         bounds[0][0], bounds[0][1], bounds[0][2],
-         bounds[1][0], bounds[1][1], bounds[1][2]);
+  // fprintf(f, "# Converted from \"%s\" by obj2pbrt\n", argv[1]);
+  // fprintf(f, "# Scene bounds: (%f, %f, %f) - (%f, %f, %f)\n\n\n",
+  //        bounds[0][0], bounds[0][1], bounds[0][2],
+  //        bounds[1][0], bounds[1][1], bounds[1][2]);
 
   int numAreaLights = 0;
   int numTriangles = 0;
@@ -949,6 +956,7 @@
 
     fprintf(f, "# Name \"%s\"\n", shape.name.c_str());
     fprintf(f, "AttributeBegin\n");
+    fprintf(f, "# MaterialName \"%s\"\n", mtl.name.c_str());
     if (mtl.emission[0] > 0 || mtl.emission[1] > 0 || mtl.emission[2] > 0) {
       fprintf(f, "AreaLightSource \"area\" \"rgb L\" [ %f %f %f ]\n",
              mtl.emission[0], mtl.emission[1], mtl.emission[2]);
@@ -1028,13 +1036,22 @@
       fprintf(f, "]\n");
     }
     if (mesh.texcoords.size()) {
-      fprintf(f, "    \"float st\" [\n    ");
-      for (size_t i = 0; i < mesh.texcoords.size(); ++i) {
-        fprintf(f, "%.10g ", mesh.texcoords[i]);
-        if (((i + 1) % 2) == 0)
-          fprintf(f, "\n    ");
+      auto tx_bounds = std::minmax_element(mesh.texcoords.begin(), mesh.texcoords.end());
+      // fprintf(stderr, "normalizing mesh uv by %.10g %.10g (count %ld)\n", *tx_bounds.first, *tx_bounds.second, mesh.texcoords.size());
+      float bound =  fmax(std::fabs(*tx_bounds.first), std::abs((float)*tx_bounds.second));
+      if(bound < 1e-5) {
+        // fprintf(stderr, "mesh has all-nil uvs, skipping\n");
+      } else {
+        fprintf(f, "    \"float uv\" [\n    ");
+        // fprintf(f, "    \"float st\" [\n    ");
+        for (size_t i = 0; i < mesh.texcoords.size(); ++i) {
+          float val = mesh.texcoords[i] / bound;
+          fprintf(f, "%.10g ", val);
+          if (((i + 1) % 2) == 0)
+            fprintf(f, "\n    ");
+        }
+        fprintf(f, "]\n");
       }
-      fprintf(f, "]\n");
     }
     numTriangles += mesh.indices.size() / 3;
     fprintf(f, "  \"integer indices\" [\n    ");
@@ -1049,8 +1066,8 @@
   if (f != stdout)
     fclose(f);
 
-  fprintf(stderr, "Converted %d meshes (%d triangles, %d mesh emitters).\n",
-          numMeshes, numTriangles, numAreaLights);
+  // fprintf(stderr, "Converted %d meshes (%d triangles, %d mesh emitters).\n",
+  //         numMeshes, numTriangles, numAreaLights);
 
   return 0;
 }
